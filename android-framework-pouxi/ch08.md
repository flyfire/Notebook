### 8.创建窗口的过程

从WMS的角度来看,一个窗口类并不是Window类,而是一个View类.WMS接收到用户消息后,需要把消息派发到窗口,View类本身并不能直接接收WMS传递过来的消息,真正接受用户消息的必须是IWindow类,而实现IWindow类的是ViewRootImpl.W类,每个W内部都包含了一个ViewRootImpl变量.WMS并不介意该窗口是属于哪个应用程序的,WMS会按一定的规则判断哪个窗口处于活动状态,然后把用户消息给W类,W类再把用户消息传递给内部的ViewRootImpl变量,剩下的消息处理就由View对象完成.

Framework定义了三种窗口类型,三种类型的定义在WindowManager类中.

+ 第一种为应用窗口.所谓的应用窗口一般是指该窗口对应一个Activity,由于加载Activity是由AMS完成的,因此,对于应用程序来讲,要创建一个应用类窗口,只能在Activity内部完成.
+ 第二种是子窗口.所谓的子窗口是指,该窗口必须有一个父窗口,父窗口可以是一个应用类型窗口,也可以是任何其他类型的窗口.
+ 第三类是系统窗口.系统窗口不需要对应任何Activity,也不需要父窗口,对于应用程序而言,理论上是无法创建系统窗口的,因为所有的应用程序都没有这个权限,然而系统进程可以创建系统窗口.

WindowManager对这三种类型进行了细化,把每一种类型都用一个int常量表示,这些实际上代表了窗口对应的层(Layer).WMS在进行窗口叠加时,会按照该int常量的大小分配不同层,int值越大,代表层的位置越靠上面,即所谓z-order.

所有Activity默认的窗口类型都是TYPE_APPLICATION,WMS再进行窗口叠加时,会动态改变应用窗口的层值,但层值不会大于99.

创建子窗口时,客户端可以指定窗口类型介于1000~1999之间,WMS在进行窗口叠加时,会动态调整层值.

创建系统窗口时,可以指定层值在2000~2999之间,WMS在进行窗口叠加时,会动态调整该层值.

| 位置                       | 定义                                                         |
| :------------------------- | :----------------------------------------------------------- |
| Activity                   | IBinder mToken                                               |
| Window                     | IBinder mAppToken                                            |
| WindowManager.LayoutParams | IBinder token                                                |
| ViewRootImpl               | View.AttachInfo mAttachInfo                                  |
| View                       | View.AttachInfo mAttachInfo                                  |
| View.AttachInfo            | IBinder mWindowToken;IBinder mPanelParentWindowToken;IWindow mWindow; |

WindowMangerImpl委托WindowManagerGlobal进行addView,WindowManagerGlobal中维护了三个数组,用于保存该应用程序中所拥有的窗口的状态,它们分别是:

+ ``ArrayList<View> mViews``这里的每一个View对象都将成为WMS所认为的一个窗口
+ ``ArrayList<ViewRootImpl> mRoots``所有的ViewRootImpl对象,mViews中每个View对象都对应的ViewRootImpl对象.
+ ``ArrayList<WindowManager.LayoutParams> mParams``当把mViews中的View对象当做一个窗口添加进WMS中,WMS要求每个被添加的窗口都要对应一个LayoutParams对象,mParams正是保存了每个窗口对应的参数对象.