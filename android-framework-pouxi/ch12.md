### 12.屏幕绘图基础

Android中的GUI系统使用客户端和服务端配合的窗口系统，即后台运行了一个绘制服务，每个应用程序都是该服务的一个客户端，当客户端需要绘制屏幕时，首先请求服务端创建一个窗口，然后给该窗口绘制内容。对于每个客户端而言，它们都感觉自己独占了屏幕，而对于服务端而言，它会给每一个客户窗口分配不同的层值，并根据用户的交互情况动态改变窗口的层值，从而对用户来讲，出现了所谓的前台窗口和后台窗口。

从进程的角度来看，该架构由2+x个进程组成，x的数量取决于系统当前正在运行的应用程序的数量，应用程序可以是APK对应的程序，也可以是任何C语言编写的linux可执行程序，2代表了SurfaceFlinger服务进程和SystemServer进程。

SurfaceFlinger进程在整个系统中只有一个实例，在系统开机后自动运行，它的作用是给每个客户端分配窗口，程序中使用Surface类表示这个窗口。正如Surface字面的意义，它是一个平面，即每个窗口是一个平面，每个平面在程序中都对应一段内存，也就是所谓的平面缓冲区，不同窗口的缓冲区大小不同，这取决于该窗口的大小，即宽度和高度，一般来讲缓冲区的大小为宽度*高度。

SurfaceFlinger的客户端必须使用SurfaceFlinger的客户端接口驱动来和sf打交道，系统中使用该接口驱动的最重要的进程就是SystemServer进程。当一个APK程序需要创建窗口时，首先在本地创建一个Surface对象，然后调用WindowManager类向WMS服务发起一个请求，请求的参数中包含该Surface对象。Surface类仅仅是一个空壳，虽然它表示的是一个窗口，但它必须经过初始化后才真正能够对应一个在屏幕上显示的窗口，而初始化的本质就是给该Surface对象分配一段屏幕缓冲区内存。WMS收到这个请求后，会通过Surface类的JNI接口调用SurfaceFlinger_client驱动，通过该client接口驱动请求sf进程创建指定的窗口。于是sf创建一段屏幕缓冲区，并在sf内部记录该窗口，然后sf会把该窗口的缓冲区地址传递给WMS，WMS再用这个地址去初始化APK程序传入的Surface对象，并最终回到APK程序中。此时APK程序中的Surface对象是一个真正的Surface对象了，因为它包含的屏幕缓冲区已经由sf创建并备案了。

APK程序有了这个Surface后，就可以给这个平面上绘制任意的内容了。然后Surface类本质上仅仅表示了一个平面，而绘制不同图案显然是一种操作，而不是一段数据，因此Android中使用了一个叫做Skia的绘图驱动库，该库使用C/C++语言编写而成，其作用就是能够进行各种平面绘制。在程序中用Canvas类来表示这个功能对象，Canvas类有很多绘制函数，比如drawColor()、drawLine()等。Surface类包含了一个函数lockCanvas()，APK应用程序可以通过该程序返回一个Canvas功能对象，然后就可以调用该对象的各种绘图函数完成对平面的绘制。