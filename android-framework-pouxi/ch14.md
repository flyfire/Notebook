### 14.WMS工作原理

WMS是Android中图形用户接口的引擎，它管理着所有窗口。所谓的“管理”大致包括创建，删除窗口，以及将某个窗口设置为焦点窗口，焦点窗口是指当前正在和用户交互的窗口。

在WMS中，窗口是由两部分内容构成的，一部分是描述该窗口的类WindowState，另一部分是该窗口在屏幕上对应的界面Surface。

窗口管理服务端要解决的核心问题如下：

+ 窗口如何布局
+ 窗口尺寸受制于哪些因素
+ 如何寻找焦点窗口
+ 窗口切换时的动画策略

  WMS的内部逻辑中，会进行三种常见的操作：assign layer，perform layout，place surface。

+ assign layer的语义是，为窗口分配层值。在WMS中，每个窗口都使用WindowState类来描述，而窗口要在界面上显示时，需要指定窗口的层值。从用户的视角来看，层值越大，其窗口越靠近用户，窗口之间的层叠正是按照层值进行的。
+ perform layout的语义是计算窗口的大小，每个窗口对象都必须有一个大小，即窗口大小，perform layout将根据状态栏大小、输入法窗口的状态、窗口动画状态计算该窗口的大小。
+ place surface的语义是，调整Surface对象的属性，并重新将其显示到屏幕上。由于assign layer和perform layout的执行结果影响的仅仅是WindowState中的参数，而能够显示到屏幕上的窗口都包含一个Surface对象，因此只有将以上执行结果中的窗口层值、大小设置到Surface对象中，屏幕上才能看出该窗口的变化。place surface的过程就是将这些值赋值给Surface对象，并告诉Surface Flinger服务重新显示这些Surface对象。

WMS接口结构是指WMS功能模块与其他功能模块之间的交互接口，其中主要包括与AMS模块及应用程序客户端的接口：

+ 应用程序在Activity中添加、删除窗口。具体实现就是通过调用WindowManager类的addView()和removeView()函数完成，这会转而调用ViewRootImpl类的相关方法，然后通过IPC调用到WMS中的相关方法完成添加、删除过程。
+ 当AMS通知ActivityThread销毁某个Activity时，ActivityThread会直接调用WindowManager中的removeView()方法删除窗口。
+ AMS中直接调用WMS，这种调用一般都不是请求WMS创建或者删除窗口，而是告诉WMS一些其他信息。比如某个新的Activity就要启动了，从而WMS会保存一个该Activity记录的引用。

在WMS内部，则全权接管了输入消息的处理和屏幕的绘制。其中输入消息的处理是借助于InputManager类完成的，而绘制屏幕则是借助于SurfaceFlinger模块完成的。

每个窗口都会对应一个WindowState对象，因为窗口的本质就是由WindowState类描述的数据对象，WindowState类中记录作为一个窗口应该有的全部属性，比如窗口的大小、在屏幕上的层值，以及窗口动画过程的各种状态信息。WindowToken描述的是窗口对应的token的相关属性，每个窗口都会对应一个WindowToken对象，但是一个窗口的所有子窗口将对应同一个WindowToken对象，即多对一的关系。如果窗口是由Activity创建的，即该窗口对应一个Activity，那么该窗口同时对应一个AppWindowToken对象。

创建窗口的时机可分为两种，第一种是程序员主动调用WindowManager类的addView()方法；另一种是当用户启动一个新的Activity或者显示一个对话框、菜单栏的时候，在这种情况下，程序员并不直接调用addView()函数，但是这些类的内部同样会间接调用addView()函数。

当客户端调用WindowManager类的addView()方法后，该方法会创建一个新的ViewRootImpl对象，然后调用ViewRootImpl类的setView()方法，该方法中会通过IPC方式调用WMS类中内联类Session类的add()方法。Session类的add()方法又会间接调用WMS的addView()方法。addView()流程内部可粗略分为三个小过程，第一个过程是进行前置处理，即首先判断参数的合法性，以确保接下来的添加操作能够顺利进行；第二个过程是具体添加和窗口有关的数据；第三个过程是后置处理，即添加窗口会引起相关状态的变化，因此需要把这些变化反映到相关的数据中。

无论何种情况，WMS要销毁一个Activity相关的窗口时，都必须调用ActivityThread.ApplicationThread的scheduleDestroyActivity()。该函数是异步执行的，它会发送一个Handler消息，然后返回消息的处理函数是handleDestroyActivity，该函数内部调用了两个重要函数，一个是removeViewImediate()，另一个是cloaseAll()，前者用于删除Activity窗口，后者用于删除Activity相关的窗口，比如Activity的启动窗口、菜单窗口、对话框窗口等。 这两个函数又都会调用各自窗口对应的ViewRootImpl对象的die()函数，每个窗口都会对应于一个ViewRootImpl对象，该函数又会调用doDie()，doDie()又会调用dispatchDetachedFromWindow()，该函数内部调用sWindowSession.remove()，这是一个IPC调用，sWindowSession是客户端中的一个全局静态变量，每个客户端对应一个该对象。

Activity attach方法中会调用Window.setWindowManager，方法中会创建WindowManagerImpl。