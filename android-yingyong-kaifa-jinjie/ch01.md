```java
	/**
     * Does the hard part of measureChildren: figuring out the MeasureSpec to
     * pass to a particular child. This method figures out the right MeasureSpec
     * for one dimension (height or width) of one child view.
     *
     * The goal is to combine information from our MeasureSpec with the
     * LayoutParams of the child to get the best possible results. For example,
     * if the this view knows its size (because its MeasureSpec has a mode of
     * EXACTLY), and the child has indicated in its LayoutParams that it wants
     * to be the same size as the parent, the parent should ask the child to
     * layout given an exact size.
     *
     * @param spec The requirements for this view
     * @param padding The padding of this view for the current dimension and
     *        margins, if applicable
     * @param childDimension How big the child wants to be in the current
     *        dimension
     * @return a MeasureSpec integer for the child
     */
    public static int getChildMeasureSpec(int spec, int padding, int childDimension) {
        int specMode = MeasureSpec.getMode(spec);
        int specSize = MeasureSpec.getSize(spec);

        int size = Math.max(0, specSize - padding);

        int resultSize = 0;
        int resultMode = 0;

        switch (specMode) {
        // Parent has imposed an exact size on us
        case MeasureSpec.EXACTLY:
            if (childDimension >= 0) {
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size. So be it.
                resultSize = size;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;

        // Parent has imposed a maximum size on us
        case MeasureSpec.AT_MOST:
            if (childDimension >= 0) {
                // Child wants a specific size... so be it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size, but our size is not fixed.
                // Constrain child to not be bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;

        // Parent asked to see how big we want to be
        case MeasureSpec.UNSPECIFIED:
            if (childDimension >= 0) {
                // Child wants a specific size... let him have it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size... find out how big it should
                // be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size.... find out how
                // big it should be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            }
            break;
        }
        //noinspection ResourceType
        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
    }
```

```java
// Fast path for layouts with no backgrounds
if ((mPrivateFlags & PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
    mPrivateFlags &= ~PFLAG_DIRTY_MASK;
    dispatchDraw(canvas);
} else {
    draw(canvas);
}                
```

在默认情况下，如果要绘制的子View本身是一个ViewGroup，且它没有背景，则不会调用``draw(canvas)``去绘制它，而是直接调用``dispatchDraw``方法去绘制它的子View。ViewGroup的绘制过程与View的绘制过程的最大区别就是在ViewGroup没有背景的情况下是不会绘制自己的，而只会去绘制它的子View。如果自定义的ViewGroup有背景或ViewGroup种调用了``setWillNotDraw(false)``，则不满足跳过绘制的条件，还是会用调用带一个参数``draw``方法来绘制ViewGroup，接着在``draw``方法中的第四步再来调用``dispatchDraw``。

``ACTION_CANCEL``,在View处理触摸事件的过程中，父容器突然将事件劫持自己处理，就会给子View下发一个``ACTION_CANCEL``事件通知。可以将``ACTION_CANCEL``当做一个``ACTION_UP``事件。

``ACTION_OUTSIZE``:``WindowManager``类中定义了窗口标记``FLAG_WATCH_OUTSIZE_TOUCH``，只有当View所在的窗口Window开启了这个标记后，才能收到用户点击窗口外面的事件。

``ACTION_OUTSIDE``其实就是窗口外部的``ACTION_DOWN``事件。

``ACTION_POINTER_DOWN``:如果先后将两个手指放置在MyView上面，当第二根手指触摸屏幕时，会触发``ACTION_POINTER_DOWN``事件的发生。``event.getActionMasked()``

``ACTION_POINTER_UP``:多点触控时，一个触控点离开屏幕时会触发该事件。

事件传递首先从父容器ViewGroup开始，父容器调用``dispatchTouchEvent``分发事件，在该方法内部会调用``onInterceptTouchEvent``判断是否为拦截事件，如果``onInterceptTouchEvent``返回true，则表示拦截View的事件，那么事件会直接传递给ViewGroup本身的``onTouchEvent``方法处理。如果``onInterceptTouchEvent``返回false(一般默认为false)，那么事件会传递给View的``dispatchTouchEvent``方法，View中没有``onInterceptTouchEvent``方法，而是直接调用``onTouchEvent``的方法处理事件。如果View的``onTouchEvent``的方法返回true，那么表示事件被处理，事件传递结束，如果返回false不处理，那么事件又会传递给父容器ViewGroup的``onTouchEvent``方法处理。

当手指在屏幕上触发触摸事件后，系统服务会将事件传递到当前显示的Activity，由Activity来继续分发事件。

``actionMasked != ACTION_DOWN`` 并且 ``mFirstTouchTarget == null``时，intercepted会被赋值为true，也就是会拦截子View的时间。``mFirstTouchTarget``是TouchTarget对象，用来保存处理触摸事件的View及触摸点的id值，当``ACTION_DOWN``事件分发下去后，如果有子View处理事件，也就是其``onTouchEvent``返回了true，那么ViewGroup就会将处理这个事件的子View用``mFirstTouchTarget``保存，如果没有子View处理``ACTION_DOWN``，那么``mFirstTouchTarget``就不会被赋值。