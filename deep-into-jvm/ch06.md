# 6.类文件结构

Class文件时一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。

根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表。无符号数属于基本的数据类型，以u1,u2,u4,u8来分别代表1个字节，2个字节，4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。表有多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info"结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型的集合。

Class文件没有任何分割符号，所以无论是顺序还是数量，甚至于数据存储的字节序(Byte Ordering，Class文件中字节序为Big-Endian)这样的细节，都是被严格限定的。

每个Class文件的头4个字节称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。

紧跟着主次版本号之后的是常量池入口，常量池可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时它还是在Class文件中第一个出现的表类型数据项目。常量池中主要存放两大类常量：字面量(Literal)和符号引用(Symbolic Reference)。字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括了下面三类常量：

+ 类和接口的全限定名
+ 字段的名称和描述符
+ 方法的名称和描述符

Java代码在进行javac编译的时候，并不想c/c++那样有连接这一步骤，而是在虚拟机加载Class文件的时候进行动态连接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。

``javap -verbose Test.class``可以输出常量池信息。

``CONSTANT_Utf8_info``的length说明了这个UTF-8编码的字符串长度是多少字节，它后面紧跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。UTF-8缩略编码与普通UTF-8编码的区别是：从"\u0001"到'\u007f'之间的字符(相当于1~127的ASCII码)的缩略编码使用一个字节表示，从'\u0080'到'\u07ff'之间的所有字符的缩略编码用两个字节表示，从'\u0800'到'\uffff'之间的所有字符的缩略编码就按照普通UTF-8编码规则使用三个字节表示。

由于Class文件中方法、字段等都需要引用``CONSTANT_Utf8_info``型常量来描述名称，所以``CONSTANT_Utf8_info``型常量的最大长度也就是Java中方法、字段名的最大长度。而这里的最大长度就是length的最大值，即u2类型能表达的最大值65535。所以Java程序中如果定义了超过64KB英文字符的变量或方法名，将会无法编译。

在常量池结束之后，结节状的连个字节代表访问标志(access_flags)，这个标志用于识别一些类火灾接口层次的访问信息。``ACC_PUBLIC``,``ACC_FINAL``,``ACC_SUPER``,``ACC_INTERFACE``,``ACC_ABSTRACT``,``ACC_SYNTHETIC``,``ACC_ANNOTATION``,``ACC_ENUM``.

类索引(this_class)和父类索引(super_class)都是一个u2类型的数据，而接口索引集合是一组u2类型的数据的集合，Class文件中由这三项数据来确定这个类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的弗雷德全限定名。接口索引集合就用来描述这个类实现了哪些接口。

类索引、父类索引和接口索引集合都按照顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为``CONSTANT_Class_info``的类描述符常量，通过``CONSTANT_Class_info``类型的常量中的索引值可以找到定义在``CONSTANT_Utf8_info``类型的常量中的全限定名字符串。对于接口索引集合，入口的第一项——u2类型的数据为接口计数器，表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0。

字段表用于描述接口或者类中声明的变量。字段包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。在Java中描述一个字段可以包含什么信息，可以包括的信息有：字段的作用域(public、private、protected修饰符)、是实例变量还是类变量(static修饰符)、可变性(final)、并发可变性(volatile修饰符，是否强制从主内存读写)、可否被序列化(transient修饰符)、字段数据类型(基本类型，对象，数组)、字段名称。上述这些信息中，各个修饰符都是布尔值，很适合使用标志位来表示，而字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。

描述符的作用是用来描述字段的数据类型、方法的参数列表(包括数量、类型以及顺序)和返回值。根据描述符规则，基本数据类型(byte、char、double、float、int、long、short、boolean)以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示。``long``用``J``表示，``boolean``用``Z``表示。对于数组类型，每一维度将使用一个前置的"["字符来描述。

字段表都包含的固定数据项目到descriptor_index为止就结束了，不过在descriptor_index之后跟随者一个属性表集合用于存储一些额外的信息，字段都可以在属性表中描述零至多项的额外信息。

字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段，比如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。

Class文件存储格式中对方法的描述与对字段的描述几乎用了完全一致的方式，方法表的结构如同字段表一样，依次包括了访问标志(access_flags)、名称索引(name_index)、描述符索引(descriptor_index)、属性表集合(attributes)几项。方法里的Java代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为"Code"的属性里面。与字段表集合相对应的，如果父类方法在子类中没有被重写(Override)，方法表集合中就不会出现来自父类的方法信息。当同样的，有可能出现由编译器自动添加的方法，最典型的便是类构造器``<cinit>``方法和实例构造器``<init>``方法。

在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。

虚拟机规范预定义的属性

| 属性名称                             | 使用位置           | 含义                                                         |
| ------------------------------------ | ------------------ | ------------------------------------------------------------ |
| Code                                 | 方法表             | Java代码编译成的字节码指令                                   |
| ConstantValue                        | 字段表             | final关键字定义的常量值                                      |
| Deprecated                           | 类、方法表、字段表 |                                                              |
| Exceptions                           | 方法表             | 方法抛出的异常                                               |
| EnclosingMethod                      | 类文件             | 仅当一个类为局部类或者匿名类是才能拥有这个属性，这个属性用于标识这个类所在的外围方法 |
| InnerClasses                         | 类文件             | 内部类列表                                                   |
| LineNumberTable                      | Code属性           |                                                              |
| LocalVariableTable                   | Code属性           | 方法的局部变量描述                                           |
| StackMapTable                        | Code属性           |                                                              |
| Signature                            | 类、方法表、字段表 | JDK1.5中新增的属性，这个属性用于支持泛型情况下的方法签名，在Java语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量(Type Variables)或参数化类型(Parameterized Types)，则Signature属性会为它记录泛型签名信息。由于Java的泛型采用擦除法实现，在为了避免类型信息被擦除后导致签名混乱，需要这个属性记录泛型中的相关信息。 |
| SourceFile                           | 类文件             |                                                              |
| SourceDebugExtension                 | 类文件             |                                                              |
| Synthetic                            | 类、方法表、字段表 | 标识方法或字段为编译器自动生成的                             |
| LocalVariableTypeTable               | 类                 | JDK1.5中新增的属性，它使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加 |
| RuntimeVisibleAnnotations            | 类、方法表、字段表 | JDK1.5中新增的属性，为动态注解提供支持。RuntimeVisibleAnnotations属性用于志明哪些注解是运行时(实际上运行时就是进行反射调用)可见的 |
| RumtimeInvisibleAnnotations          | 类、方法表、字段表 | JDK1.5中新增的属性，如RuntimeVisibleAnnotations属性作用刚好相反，用于指明哪些注解是运行时不可见的。 |
| RuntimeVisibleParameterAnnotations   | 方法表             | JDK1.5中新增的属性，作用与RuntimeVisibleAnnotations属性类似，只不过作用对象为方法参数 |
| RuntimeInvisibleParameterAnnotations | 方法表             | JDK1.5中新增的属性，作用与RuntimeInvisibleAnnotations属性类似，只不过作用对象为方法参数 |
| AnnotationDefault                    | 方法表             | JDK1.5中新增的属性，用于记录注解类元素的默认值               |
| BootstrapMethods                     | 类文件             | JDK1.7中新增的属性，用于保存invokedynamic指令引用的引导方法限定符 |

### Code属性

Java程序方法体中的代码经过javac编译器处理后，最终变为字节码指令存储在Code属性内。Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，比如接口或者抽象类中的方法就不存在Code属性。

code_length和code用来存储java源程序编译后生成的字节码指令。code_length代表字节码长度，code是用于存储字节码指令的一系列字节流。既然叫字节码指令，那么每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及参数应当如何理解。一个u1数据类型的取值范围为0x00~0xFF，对应十进制0~255，也就是一共可以表达256条指令，目前，Java虚拟机规范已经定义了其中约200条编码值对应的指令含义。

关于code_length，有一件值得注意的事情，虽然它是一个u4类型的长度值，理论上最大值可以达到2^32-1，但是虚拟机规范中明确限制了一个方法不允许超过65535条字节码指令，即它实际只使用了u2的长度，如果超过这个限制，javac编译器也会拒绝编译。

在任何实例方法里面，都可以用"this"关键字访问到此方法所属的对象。这个访问机制对Java程序的编写很重要，而它的实现却非常简单，仅仅是通过javac编译器编译的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数而已。因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个Slot为来存放对象实例的引用。

在字节码指令之后的是这个方法的显式异常处理表集合，异常表对于Code属性来说并不是必须存在的。异常表包含4个字段，这些字段的含义为：如果当字节码在第start_pc行到第end_pc行之间(不含第end_pc行)出现了类型为catch_type或者其子类的异常(catch_type为指向一个CONSTANT_Class_info型常量的索引)，则转到第handler_pc行继续处理。当catch_type的值为0时，代表任意异常情况都需要转向到handler_pc处进行处理。

异常表实际上是Java代码的一部分，编译器使用异常表而不是简单的跳转命令来实现Java异常及finally处理机制。1.4.2之后编译器自动在每段可能的分支路径之后都将finally语句块的内容冗余生成一遍来实现finally语义。

### Exceptions属性

Exceptions属性是在方法表中与Code属性平级的一项属性。Exceptions属性的作用是列举出方法中可能抛出的受检异常(Checked Exceptions)，也就是方法描述时在throws关键字后面列举的异常。

### LineNumberTable属性

LineNumberTable属性用于描述Java源码与字节码行号(字节码的偏移量)之间的对应关系。

### LocalVariableTable属性

LocalVariableTable属性用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系。

### SourceFile属性

### ConstantValue属性

ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量(类变量)才可以使用这项属性。类似"int x = 123"和"static int x = 123"这样的变量定义在Java程序中是非常常见的事情，但虚拟机对这两种变量赋值的方式和时刻都有所不同。对于非static类型的变量(也就是实例变量)的赋值是在实例构造器``<init>``方法中进行的；而对于类变量，则有两种方式可以选择：在类构造区``<cinit>``方法中或者使用ConstantValue属性。Sun Javac编译器的选择是：如果同时使用final和static来修饰一个变量，并且这个变量的数据类型是基本类型或者java.lang.String的话，就生成ConstantValue属性进行初始化，如果这个变量没有被final修饰，或者并非基本数据类型及字符串，则将会选择在``<cinit>``方法中进行初始化。