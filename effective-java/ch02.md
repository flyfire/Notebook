# 第2章 创建和销毁对象

### 1. 考虑用静态工厂方法代替构造器

+ 静态工厂方法与构造器不同的第一大优势在于，他们有名称，产生的客户端代码更容易阅读。
+ 静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新的对象。``Boolean.valueOf(boolean)``
+ 静态工厂方法与构造器不同的第三大优势在于，它们可以返回原返回类型的任何子类型的对象。``java.util.EnumSet``没有公有构造器，只有静态工厂方法。它们返回两种实现类之一，具体则取决于底层枚举类型的大小：如果它的元素有64个或者更少，就像大多数枚举类型一样，静态工厂方法就会返回一个``RegularEnumSet``实例，用单个long进行支持；如果枚举类型有65个或者更多元素，工厂就返回``JumboEnumSet``实例，用long数组进行支持。
+ 静态工厂方法的第四大优势在于，在创建参数化类型实例的时候，它们使代码变得更加简洁。在调用参数化类的构造器时，即使类型参数很明显，也必须指明。这通常要求你连续两次提供类型参数。``Map<String, List<String>> m = new HashMap<String, List<String>>();``,随着类型参数变得越来越长，越来越复杂，这一冗长的说明也很快变得痛苦起来。但是有了静态工厂方法，编译器可以替你找到类型参数，这称作类型推导。

```java
public static <K, V> HashMap<K, V> newInstance() {
    return new HashMap<K, V>();
}
```

+ 静态工厂方法的主要缺点在于，类如果不含共有的或者受保护的构造器，就不能被子类化。
+ 静态工厂方法的第二个缺点在于，他们与其他静态方法实际上没有任何区别。下面是静态工厂方法的一些惯用名称：``valueOf``，``of``，``getInstance``，``newInstance``，``getType``，``newType``。

### 2. 遇到过个构造器参数时要考虑用构建器

静态工厂方法和构造器有个共同的局限性：它们都不能很好地扩展到大量的可选参数。重叠构造器模式可行，但是当有许多参数的时候，客户端代码会很难编写，并且仍然较难以阅读。JavaBeans模式，这种模式下，调用一个无参构造器来创建对象，然后调用setter方法来设置每个必要的参数，以及每个相关的可选参数。JavaBeans模式自身有很严重的缺点，因为构造过程被分到了几个调用中，在构造过程中JavaBean可能处于不一致的状态。类无法仅仅通过检验构造器参数的有效性来保证一致性。JavaBeans模式阻止了把类做成不可变的可能，这就需要程序员付出额外的努力来确保它的线程安全。

Builder模式不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器（或者静态工厂），得到一个builder对象，然后客户端在builder对象上调用类似于setter的方法，来设置每个相关的可选参数，最后，客户端调用无参的build方法来生成不可变的对象，这个builder类是它构建的类的静态成员类。builder模式模拟了具名的可选参数。

与构造器相比，builder的微略优势在于，builder可以由多个可变的参数varargs。构造器就像方法一样，只能有一个可变参数。

如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builder模式就是种不错的选择。特别是当大多数参数都是可选的时候，与使用传统的重叠构造器模式相比，使用Builder模式的客户端代码将更易于阅读和编写，构建器也比JavaBeans更加安全。

### 3. 用私有构造器或者枚举类型强化Singleton属性

Java1.5之前实现Singleton有两种方法，这两种方法都要把构造器保持为私有的，并导出公有的静态成员，以便允许客户端能够访问该类的唯一实例。

为了使Singleton类变成是可序列化的，仅仅在声明中加上``implements Serializable``是不够的。为了维护名保证Singleton，必须声明所有实例域都是瞬时transient的，并提供一个``readResolve``方法。否则，每次反序列化一个序列化的实例时，都会创建一个新的实例。

从Java1.5起，实现Singleton还有第三种方法，只需编写一个包含单个元素的枚举类型。这种方法在功能上与公有域方法相近，但是它更加简洁，无偿提供了序列化机制，绝对防止多次实例化，即使是在面对复杂的序列化或者反射攻击的时候。

```java
Constructor.java newInstance

if ((clazz.getModifiers() & Modifier.ENUM) != 0)
            throw new IllegalArgumentException("Cannot reflectively create enum objects");
```

```java
Enum.java 

	/**
     * enum classes cannot have finalize methods.
     */
    protected final void finalize() { }

    /**
     * prevent default deserialization
     */
    private void readObject(ObjectInputStream in) throws IOException,
        ClassNotFoundException {
        throw new InvalidObjectException("can't deserialize enum");
    }

    private void readObjectNoData() throws ObjectStreamException {
        throw new InvalidObjectException("can't deserialize enum");
    }
```

