# 第6章.枚举和注解

### 30.用enum代替int常量

### 31.用实例域代替序数

所有的枚举都有一个``oridinal``方法，它返回每个枚举常量在类型中的数字位置。

永远不要根据枚举的序数导出与它关联的值，而是要将它保存在一个实例域中。

Enum规范中谈到``oridinal``时这么写到：大多数程序员都不需要这个方法。它是设计成用于像``EnumSet``和``EnumMap``这种基于枚举的通用数据结构的。

### 32.用EnumSet代替位域

正是因为枚举类型要用在集合Set中，所以没有理由用位域来表示它。EnumSet类集位域的简洁和性能优势及枚举类型的所有优点于一身。

### 33.用EnumMap代替序数索引

最好不要用序数来索引数组，而要使用``EnumMap``。若要表示的这种关系是多维的，就使用``EnumMap<...,EnumMap<...>>``。

### 34.用接口模拟可伸缩的枚举

虽然枚举类型不是可扩展的，但接口类型则是可扩展的，它是用来表示API中的操作的接口类型。你可以定义另一个枚举类型，它实现这个接口，不够用这个新类型的实例代替基本类型。

```java
public interface Operation {
    double apply(double a, double b);
}
public enum BasicOperation implements Operation{
    PLUS("+") {
        public double apply(double a, double b) { return a + b;}
    },
    MINUS("-") {
        @Override
        public double apply(double a, double b) {
            return a - b;
        }
    },
    TIMES("*") {
        @Override
        public double apply(double a, double b) {
            return a*b;
        }
    },
    DIVIDE("/") {
        @Override
        public double apply(double a, double b) {
            return a/b;
        }
    };
    private final String symbol;
    BasicOperation(String s) {
        this.symbol = s;
    }

    @Override
    public String toString() {
        return symbol;
    }
}
public class Test {
    private static <T extends Enum<T> & Operation> void test(Class<T> opSet, double x, double y) {
        for (Operation op : opSet.getEnumConstants()) {
            System.out.printf("%f %s %f = %f%n", x, op, y, op.apply(x, y));
        }
    }

    public static void main(String[] args) {
        double a = 10.0;
        double b = 5.0;
        test(BasicOperation.class, a, b);
    }
}
```

