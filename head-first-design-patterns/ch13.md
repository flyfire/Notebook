# 13.与设计模式相处

创建型模式涉及到将对象实例化，这类模式都提供一个方法，将客户从所需要实例化的对象中解耦。

创建型：

+ Singleton
+ Builder
+ Prototype
+ Abstract Factory
+ Factory Method

只要是行为型模式，都涉及到类和对象如何交互和分配职责。

行为类：

+ Mediator
+ Visitor
+ Template Method
+ Iterator
+ Command
+ Memento
+ Interpreter
+ Observer
+ Chain of Responsibility
+ State
+ Strategy

结构型模式可以让你把类或对象组合到更大的结构中。

结构型：

+ Decorator
+ Proxy
+ Facade
+ Composite
+ Flyweight
+ Bridge
+ Adapter

类模式描述类之间的关系如何通过继承定义。类模式的关系是在编译时建立的。

类模式：

+ Template Method
+ Factory Method
+ Adapter
+ Interpreter

对象模式描述对象之间的关系，而且主要是利用组合定义。对象模式的关系通常在运行时建立，而且更加动态、更有弹性。

对象模式：

+ Composite
+ Visitor
+ Decorator
+ Proxy
+ Strategy
+ Bridge
+ Flyweight
+ Iterator
+ Command
+ Memento
+ Facade
+ Observer
+ Chain of Responsibility
+ Mediator
+ Prototype
+ State
+ Abstract Factory
+ Builder
+ Singleton

一句话概括模式：

+ 装饰者：包装一个对象，以提供新的行为。
+ 迭代器：在对象的集合之中游走，而不暴露集合的实现。
+ 状态：封装了基于状态的行为，并使用委托在行为之间切换。
+ 外观：简化一群类的接口
+ 策略：封装可以互换的行为，并使用委托来决定要使用哪一个。
+ 代理：包装对象，以控制对此对象的访问。
+ 工厂方法：由子类决定要创建的具体类是哪一个。
+ 适配器：封装对象，并提供不同的接口。
+ 观察者：让对象能够在状态改变时被通知。
+ 模板方法：由子类决定如何实现一个算法中的步骤。
+ 组合：客户用一致的方式处理对象集合和单个对象。
+ 单件：确保有且只有一个对象被创建。
+ 抽象工厂：运行客户创建对象的家族，而无需指定它们的具体类。
+ 命令：封装请求成为对象。

#### 桥接

使用桥接模式（Bridge Pattern）不只改变你的实现，也改变你的抽象。

桥接的优点：

+ 将实现予以解耦，让它和界面之间不再永久绑定。
+ 抽象和实现可以独立扩展，不会影响到对方。
+ 对于“具体的抽象类”所做的改变，不会影响到客户。

桥接的用途和缺点：

+ 适合使用在需要跨越多个平台的图形和窗口系统上。
+ 当需要用不同的方式改变接口和实现时，你会发现桥接模式很好用。
+ 桥接模式的缺点是增加了复杂度。

#### 生成器

使用生成器模式（Builder Pattern）封装一个产品的构造过程，并允许按步骤构造。

生成器的优点：

+ 将一个复杂对象的创建过程封装起来
+ 允许对象通过多个步骤来创建，并且可以改变过程（这和只有一个步骤的工厂模式不同）
+ 向客户隐藏产品内部的表现
+ 产品的实现可以被替换，因为客户只看到一个抽象的接口

生成器的用途和缺点：

+ 经常被用来创建组合结构
+ 与工厂模式相比，采用生成器模式创建对象的客户，需要具备更多的领域知识。

#### 责任链

当你想要让一个以上的对象有机会能够处理某个请求的时候，就使用责任链模式（Chain of Responsibility Pattern）。

责任链的优点：

+ 将请求的发送者和接受者解耦。
+ 可以简化你的对象，因为它不需要知道链的结构。
+ 通过改变链内的成员或调动它们的次序，允许你动态地新增或者删除责任。

责任链的用途和缺点：

+ 经常被使用在窗口系统中，处理鼠标和键盘之类的时间。
+ 并不保证请求一定会被执行；如果没有任何对象处理它的话，它可能会落到链尾端之外。
+ 可能不容易观察运行时的特征，有碍于除错。

#### 蝇量

如想让某个类的一个实例能用来提供许多“虚拟实例”，就使用蝇量模式（Flyweight Pattern）。

蝇量的优点：

+ 减少运行时对象实例的个数，节省内存。
+ 将许多“虚拟”对象的状态集中管理。

蝇量的用途和缺点：

+ 当一个类有许多的实例，而这些实例能被同一方法控制的时候，我们就可以使用蝇量模式。
+ 蝇量模式的缺点在于，一旦你实现了它，那么单个的逻辑实例将无法拥有独立而不同的行为。

#### 解释器

使用解释器模式（Interpreter Pattern）为语言创建解释器。

解释器模式的优点：

+ 将每一个语法规则表示成一个类，方便于实现语言。
+ 因为语法由许多类表示，所以你可以轻易地改变或扩展此语言。
+ 通过在类结构中加入新的方法，可以在解释的同时增加新的行为，例如打印格式的美化或者进行复杂的程序验证。

解释器的用途和缺点：

+ 当你需要实现一个简单的语言时，使用解释器。
+ 当你有一个简单的语法，而且简单比效率更重要时，使用解释器。
+ 可以处理脚本语言和编程语言。
+ 当语法规则的数目太大时，这个模式可能会变得非常繁杂。在这种情况下，使用解析器/编译器的产生器可能更合适。

#### 中介者

使用中介者模式（Mediator Pattern）来集中相关对象之间复杂的沟通和控制方式。

中介者的优点：

+ 通过将对象彼此解耦，可以增加对象的复用性。
+ 通过将控制逻辑集中，可以简化系统维护。
+ 可以让对象之间所传递的消息变得简单而且大幅减少。

中介者的用途和缺点：

+ 中介者常常被用来协调相关的GUI组件。
+ 中介者模式的缺点是，如果设计不当，中介者对象本身会变得过于复杂。

#### 备忘录

当你需要让对象返回之前的状态时（例如，撤销），就使用备忘录模式（Memento Pattern）。

备忘录的优点：

+ 将被储存的状态放在外面，不要和关键对象混在一起，这可以帮助维护内聚。
+ 保持关键对象的数据封装。
+ 提供了容易实现的恢复能力。

备忘录的用途和缺点：

+ 备忘录用于储存状态。
+ 使用备忘录的缺点：储存和恢复状态的过程可能相当耗时。
+ 在Java系统中，其实可以考虑使用序列化机制储存系统的状态。

#### 原型

当创建给定类的实例的过程很昂贵或很复杂时，就使用原型模式（Prototype Pattern）。

原型的优点：

+ 向客户隐藏制造新实例的复杂性
+ 提供让客户能够产生未知类型对象的选项
+ 在某些环境下，复制对象比创建新对象更有效。

原型的用途和缺点：

+ 在一个复杂的类层次中，当系统必须从其中的许多类型创建新对象时，可以考虑原型。
+ 使用原型模式的缺点：对象的复制有时相当复杂。

#### 访问者

当你想要为一个对象的组合增加新的能力，且封装并不重要时，就使用访问者模式。访问者必须参观组合内的每个元素；这样的功能是在导游（Traverser）对象中，访问者通过导游的引导，收集组合中所有对象的状态。一旦状态被收集了，客户就可以让访问者对状态进行各种操作。当需要新的功能时，只要加强访问者即可。

访问者的优点：

+ 允许你对组合结构加入新的操作，而无需改变结构本身。
+ 想要加入新的操作，相对容易。
+ 访问者所进行的操作，其代码是集中在一起的。

访问者的用途和缺点：

+ 当采用访问者模式的时候，就会打破组合类的封装。
+ 因为游走的功能牵涉其中，所以对组合结构的改变就更加困难。

