# 2.线程安全性

要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享的和可变的状态的访问。共享意味着变量可以由多个线程同时访问，而可变意味着变量的值在其生命中期内可以发生变化。

Java中的主要同步机制是关键字synchronized，它提供了一种独占的加锁方式，但同步这个术语还包括volatile类型的变量，显式锁以及原子变量。

当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。

无状态对象一定是线程安全的。

要避免竞态条件问题，就必须在某个修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或者之后读取和修改状态，而不是在修改状态的过程中。

要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。

同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。以synchronized来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的synchronized方法以Class对象作为锁。

每个Java对象都可以用作一个实现同步的锁，这些锁被称为内置锁或监视器锁。

Java的内置锁相当于一种互斥体（或互斥锁），这意味着最多只有一个线程能持有这种锁。当线程A尝试获取一个由线程B持有的锁时，线程A必须等待或者阻塞，直到线程B释放这个锁。如果B永远不释放锁，那么A也将永远地等下去。

对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。每个共享可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。

对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。

当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或控制台I/O），一定不要持有锁。