# 3.对象的共享

最低安全性适用于绝大部分变量，但是存在一个例外：非volatile类型的64位数值变量(double和long)，Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非volatile类型的long和double类型，JVM允许将64位的读操作或写操作分解为两个32位的操作。当读取一个非volatile类型的long变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值的低32位。因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非用关键字volatile来声明它们，或者用锁保护起来。

在锁M上调用unlock之前的所有操作结果对于在M上调用lock之后的线程都是可见的。

加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。

Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型变量时总会返回最新写入的值。

volatile变量对可见性的影响比volatile变量本身更为重要。当线程A首先写入一个volatile变量并且线程B随后读取该变量时，在写入volatile变量之前对A可见的所有变量的值，在B读取了volatile变量后，对B也是可见的。

加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。

当且仅当满足以下所有条件时，才应该使用volatile变量：

+ 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
+ 该变量不会与其他状态变量一起纳入不变性条件中。
+ 在访问变量时不需要加锁。

当且仅当对象的构造函数返回时，对象才处于可预测的和一致的状态。因此，当从对象的构造函数中发布对象时，只是发布了一个尚未构造完成的对象。不要在构造过程中使this引用溢出。

在构造过程中使this引用溢出的一个常见错误是，在构造函数中启动一个线程。当对象在其构造函数中创建一个线程时，无论是显式创建（通过将它传给构造函数）还是隐式创建（由于Thread或Runnable是该对象的一个内部类），this引用都会被新创建的线程共享。在对象尚未完全构造之前，新的线程就可以看见它。在构造函数中创建线程并没有错误，但最好不要立即启动它，而是通过一个start或initialize方法来启动。在构造函数中调用一个可改写的实例方法时（既不是私有方法，也不是终结方法），同样会导致this引用在构造过程中逸出。

当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭（Thread Confinement），它是实现线程安全性的最简单的方式之一。当某个对象封闭在一个线程中时，这种用法将自动实现线程安全性，即使被封闭的对象本身不是线程安全的。

Java语言及其核心库提供了一些机制来帮助维持线程封闭性，例如局部变量和ThreadLocal类，但即便如此，程序员仍然需要负责确保封闭在线程中的对象不会从线程中逸出。

局部变量的固有属性之一就是封闭在执行线程内，它们位于执行线程的栈中，其他线程无法访问这个栈。

对于基本类型的局部变量，无论如何都不会破坏栈封闭性。由于任何方法都无法获得对基本类型的引用，因此Java语言的这种语义就确保了基本类型的局部变量始终封闭在线程内。在维持对象引用的栈封闭性时，程序员需要多做一些工作以确保被引用的对象不会逸出。

ThreadLocal类能使线程中的某个值与保存值的对象关联起来。ThreadLocal提供了get与set等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此get总是返回有当前执行线程在调用set时设置的最新值。

满足同步需求的另一种方法是使用不可变对象。如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象。线程安全性是不可变对象的固有属性之一，它们的不变性是由构造函数创建的，只要它们的状态不改变，那么这些不变性条件就能得以维持。不可变对象一定是线程安全的。

当满足以下条件时，对象才是不可变的：

+ 对象创建以后其状态就不能修改
+ 对象的所有域都是final类型
+ 对象是正确创建的（在对象创建期间，this引用没有逸出）

在Java内存模型中，final域还有着特殊的语义。final域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无须同步。

对于在访问和更新多个相关变量时出现的竞态条件，可以通过将这些变量全部保存在一个不可变对象中来消除。

由于不可变对象是一种非常重要的对象，因此Java内存模型为不可变对象的共享提供了一种特殊的初始化安全性保证。

即使某个对象的引用对其他线程是可见的，也并不意味着对象状态对于使用该对象的线程来说一定是可见的。为了确保对象状态能呈现出一致性，就必须使用同步。

可变对象必须通过安全的方式来发布，这意味着在发布和使用该对象的线程时都必须使用同步。

要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布：

+ 在静态初始化函数中初始化一个对象引用。
+ 将对象的引用保存到volatile类型的域或者AtomicReferance对象中。
+ 将对象的引用保存到某个正确构造对象的final类型域中。
+ 将对象的引用保存到一个由锁保护的域中。

类库中的其他数据传递机制（例如Future和Exchanger）同样能实现安全发布。

通常，要发布一个静态构造的对象，最简单和最安全的方式是使用静态的初始化器。静态初始化器由JVM在类的初始化阶段执行。由于在JVM内部存在着同步机制，因此通过这种方式初始化的任何对象都可以被安全地发布。

在没有额外的同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。

在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：

+ 线程封闭。线程封闭的对象只能有一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。
+ 只读共享。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。
+ 线程安全共享。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。
+ 保护对象。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。