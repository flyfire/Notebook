# 10.避免活跃性危险

锁顺序死锁

动态的锁顺序死锁（银行转账），解决这个问题，必须定义锁的顺序，并在整个应用程序中都按照这个顺序来获取锁。在指定锁的顺序时，可以使用System.identityHashCode方法，该方法将返回由Object.hashCode返回的值。

资源死锁

支持定时的锁

通过线程转储信息来分析死锁

当线程由于无法访问它所需要的资源而不能继续执行时，就发生了饥饿。引发饥饿的最常见资源就是CPU时钟周期。如果在Java应用程序中对线程的优先级使用不当，或者在持有锁时执行一些无法结束的结构（例如无限循环，或者无限制地等待某个资源）那么也可能导致饥饿，因为其他需要这个锁的线程将无法得到它。

活锁时另一种形式的活跃性问题，该问题尽管不会阻塞线程，但也不能继续执行，因为线程将不断重复执行相同的操作，而且总会失败。活锁通常发生在处理事务消息的应用程序中。要解决活锁问题，需要在重试机制中引入随机性。