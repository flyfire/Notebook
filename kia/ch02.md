# 2.Kotlin基础

在kotlin中，``if``是表达式，而不是语句。语句和表达式的区别在于，表达式有值，并且能作为另一个表达式的一部分使用，而语句总是包围着它的代码块中的顶层元素，并且没有自己的值。在Java中，所有的控制结构都是语句。而在kotlin中，除了循环（for、do和do/while）以外大多数控制结构都是表达式。这种结合控制结构和其他表达式的能力让你可以简明扼要地表示许多常见的模式。

```kotlin 
fun max(a : Int, b : Int) : Int = if(a > b) a else b 
```

在Java中声明变量的时候会以类型开始。在Kotlin中这样是行不通的，因为许多变量声明的类型都可以忽略。所以在Kotlin中以关键字开始，然后是变量名称，最后可以加上类型（不加也可以）。

声明变量的关键字有两个：

+ ``val``，来自value，不可变引用。使用val声明的变量不能在初始化之后再次赋值。它对应的是Java的final变量。
+ ``var``，来自variable，可变引用。这种变量的值可以被改变。这种声明对应的是普通的Java变量。

更简单的字符串格式化：字符串模板

在Java中，字段和其访问器的组合常常被称为属性，许多框架严重依赖这个概念。在kotlin中，属性是头等的语言特性，完全代替了字段和访问器方法。在类中声明一个属性和声明一个变量一样：使用``val``或``var``关键字。声明成``val``的属性是只读的，而``var``属性是可变的。基本上，当你声明属性的时候，你就声明了对应的访问器（只读属性有一个getter，而可写属性既有getter也有setter）

自定义访问器

Kotlin不区分导入的事类还是函数，而且它允许使用``import``关键字导入任何种类的声明。可以直接导入顶层函数的名称。也可以在包名称后加上``*``来导入特定包中定义的所有声明。注意这种星号导入不仅让包中定义的类可见，也会让顶层函数和属性可见。

在kotlin中，可以把多个类放在同一个文件中，文件的名字还可以随意选择。Kotlin也没有对磁盘上源文件的布局强加任何限制。

```kotlin
enum class Color {
    RED, ORAGNE
}
```

Kotlin使用``enum class``两个关键字来声明枚举，而Java只有``enum``一个关键字。Kotlin中``enum``是一个所谓的软关键字：只有当它出现在``class``前面时才有特殊的意义，在其他地方可以把它当做普通的名称使用。和Java一样，枚举并不是值的列表：可以给枚举类声明属性和方法。

Java中的``switch``语句在Kotlin对应的结构是``when``，和``if``相似，``when``是一个有返回值的表达式，因此可以写一个直接返回``when``表达式的表达式体函数。Kotlin中``when``结构比Java中的``switch``强大的多。``switch``要求必须使用常量（枚举常量、字符串或者数字字面值）作为分支条件，和它不一样，``when``允许使用任何对象。如果没有给``when``表达式提供参数，分支条件就是任意的布尔表达式。

智能转换：合并类型检查和转换

``if``和``when``都可以使用代码块作为分支体。这种情况下，代码块中的最后一个表达式就是结果。

``for``循环仅以唯一一种形式存在，和``Java``的``for-each``循环一致。在Kotlin中没有常规的Java for循环，为了替代这种最常见的循环用法，Kotlin使用了区间的概念。区间本质上就是两个值之间的间隔。使用``..``运算符来表示区间：

```kotlin
val oneToTen = 1..100
```

注意Kotlin的区间是闭合的，意味着第二个值始终是区间的一部分。

```kotlin
for(i in 100 downTo 1 step 2) {
    // todo
}
```

``..``语法始终创建的是包含结束值的区间。许多情况下，迭代不包含指定结束值的半壁和区间更方便。使用``until``函数可以创建这样的区间。

迭代map

使用``in``来检查一个值是否在区间中，``!in``来检查这个值是否不在区间中。``in``和``!in``也适用于``when``表达式。 

区间也不仅限于字符，假如有一个支持实例比较操作的任意类（实现了java.lang.Comparable接口），就能创建这种类型的对象的区间

Kotlin的异常处理和Java以及其他许多语言的处理方式类似。一个函数可以正常结束，也可以在出现错误的情况下抛出异常。方法的调用者能捕获到这个异常并处理它：如果没有被处理，异常会沿着调用栈再次抛出。和Java不同的是，Kotlin中``throw``结构是一个表达式，能作为另一个表达式的一部分使用。和Java中一样，使用带有``catch``和``finally``子句的``try``结构来处理异常。Kotlin并不区分受检异常和未受检异常。不用指定函数抛出的异常，而且可以处理也可以不处理异常。

Kotlin中``try``关键字就像``if``和``when``一样，引入了一个表达式，可以把它的值赋给一个变量。不同于``if``，你总是需要用花括号把语句主体括起来。和其他语句一样，如果其主体包含多个表达式，那么整个``try``表达式的值就是最后一个表达式的值。
