# 9.泛型

实化类型参数允许你在运行时的内联函数调用中引用作为类型实参的具体类型（对普通类和函数来说，这样行不通，因为类型实参在运行时会被擦除）。

声明点类型可以说明一个带类型参数的泛型类型，是否是另一个泛型类型的子类型或超类型，它们的基础类型相同但类型参数不同。例如，它能调节是否可以把``List<Int>``类型的参数传递给期望``List<Any>``的函数。使用点变型在具体使用一个泛型类型时做同样的事，达到和Java通配符一样的效果。

和Java不同，kotlin从一开始就有泛型，所以它不支持原生态类型，类型实参必须定义。kotlin始终要求类型实参要么被显式地说明，要么能被编译器推导出来。

普通（即非扩展）属性不能拥有类型参数，不能在一个类的属性中存储多个不同类型的值，隐藏生命泛型非扩展函数没有任何意义。

类型参数约束可以限制作为泛型类和泛型函数的类型实参的类型。如果你把一个类型指定为泛型类型形参的上界约束，在泛型类型具体的初始化中，其对应的类型实参就必须是这个具体类型或者它的子类型。

```java 
<T extends Number> T sum(List<T> list){ ... }
```

```kotlin 
fun <T : Number> List<T>.sum() : T
```

在一个类型参数上指定多个约束

```kotlin
fun <T> ensureTrailingPeriod(seq : T) where T : CharSequence, T : Appendable {
    if(!seq.endsWith('.')) { // 调用为CharSequence接口定义的扩展函数
        seq.append('.') //调用Appendable接口的方法
    }
}
```

如果你声明的是泛型类或者泛型函数，任何类型实参，包括那些可空的类型实参，都可以替换他的类型形参。事实上，没有指定上界的类型形参将会使用``Any?``这个默认的上界。

JVM上的泛型一般是通过类型擦除实现的，就是说泛型类实例的类型实参在运行时是不保留的。可以声明一个``inline``函数，使其类型实参不被擦除（或者，按照kotlin术语，称作实化）。

擦除泛型类型信息是有好处的，应用程序使用的内存总量较小，因为要保存在内存中的类型信息更少。

``if(value is List<*>) { ... } ``可以认为它就是拥有未知类型实参的泛型类型（或者类比于Java的List<?>）