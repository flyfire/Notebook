## 4.RxJava的线程操作

Scheduler是RxJava对线程控制器的一个抽象。

| Scheduler | 作用 |
| single | 使用定长为1的线程池，重复利用这个线程 |
| newThread | 每次都启用新线程，并在新线程中执行操作 |
| computation | 使用固定的线程池(Fixed Scheduler Pool)，大小为CPU核数，适用于CPU密集型计算 |
| io | 适合I/O操作(读写文件，读写数据库，网络信息交互等)所使用的Scheduler。行为模式和newThread()差不多，区别在于io的内部实现是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下，io比newThread更有效率 |
| trampoline | 直接在当前线程运行，如果当前线程有其他任务正在执行，则会先暂停其他任务 |
| Scheculers.from | 将java.util.concurrent.Executor转换成一个调度器实例，即可以自定义一个Executor来作为调度器 |

默认情况下不做任何线程处理，Observable和Observer处于同一线程中。如果想要切换线程，则可以使用subscribeOn()和observerOn().

subscribeOn通过接收一个Scheduler参数，来指定对数据的处理运行在特定的线程调度器Scheduler上。若多次执行subscribeOn，则只有一次起作用。在RxJava的链式操作中，数据的处理是自下而上的，这点与数据的发射正好相反。如果多次调用subscribeOn，则最上面的线程切换最晚执行，所以就变成了只有第一次切换线程才有效。