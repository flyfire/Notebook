### 1.Activity的生命周期和启动模式

新Activity启动之前,栈顶的Activity需要先onPause之后,新的Activity才能启动.不能在onPause中做重量级的操作,因为必须onPause执行完成以后新Activity才能resume.onPause和onStop都不能执行耗时的操作,尤其是onPause,这也意味着,应当尽量在onStop中做操作,从而使得新Activity尽快显示出来并切换到前台.

在默认情况下,如果我们的Activity不做特殊处理,那么当系统配置发生改变后,Activity就会被销毁并重新创建.当系统配置发生改变后,Activity会被销毁,其onPause,onStop,onDestroy均会被调用,同时由于Activity是在异常情况下终止的,系统会调用onSaveInstanceState来保存当前Activity的状态.这个方法的调用时机是在onStop之前,它和onPause没有既定的时序关系,它既可能在onPause之前调用,也可能在onPause之后调用.需要强调的一点是,这个方法只会出现在Activity被异常终止的情况下,正常情况下系统不会回调这个方法.当Activity被重新创建后,系统会调用onRestoreInstanceState,并且把Activity销毁时onSaveInstanceState方法所保存的Bundle对象作为参数同时传递给onRestoreInstanceState和onCreate方法.因此,可以通过onRestoreInstanceState和onCreate方法来判断Activity是否被重建了,如果被重建了,那么可以取出之前保存的数据并恢复,从时序上来说,onRestoreInstanceState的调用时机在onStart之后.

系统配置中有很多内容,如果当某项内容发生改变后,我们不想系统重新创建Activity,可以给Activity指定configChanges属性.指定了configChanges属性后,配置发生变化后,Activity不会重新创建,也没有调用onSaveInstanceState和onRestoreInstanceState来存储和恢复数据,取而代之的是系统调用了Activity的onConfigurationChanged方法.

