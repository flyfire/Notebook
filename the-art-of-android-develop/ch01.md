### 1.Activity的生命周期和启动模式

新Activity启动之前,栈顶的Activity需要先onPause之后,新的Activity才能启动.不能在onPause中做重量级的操作,因为必须onPause执行完成以后新Activity才能resume.onPause和onStop都不能执行耗时的操作,尤其是onPause,这也意味着,应当尽量在onStop中做操作,从而使得新Activity尽快显示出来并切换到前台.

在默认情况下,如果我们的Activity不做特殊处理,那么当系统配置发生改变后,Activity就会被销毁并重新创建.当系统配置发生改变后,Activity会被销毁,其onPause,onStop,onDestroy均会被调用,同时由于Activity是在异常情况下终止的,系统会调用onSaveInstanceState来保存当前Activity的状态.这个方法的调用时机是在onStop之前,它和onPause没有既定的时序关系,它既可能在onPause之前调用,也可能在onPause之后调用.需要强调的一点是,这个方法只会出现在Activity被异常终止的情况下,正常情况下系统不会回调这个方法.当Activity被重新创建后,系统会调用onRestoreInstanceState,并且把Activity销毁时onSaveInstanceState方法所保存的Bundle对象作为参数同时传递给onRestoreInstanceState和onCreate方法.因此,可以通过onRestoreInstanceState和onCreate方法来判断Activity是否被重建了,如果被重建了,那么可以取出之前保存的数据并恢复,从时序上来说,onRestoreInstanceState的调用时机在onStart之后.

系统配置中有很多内容,如果当某项内容发生改变后,我们不想系统重新创建Activity,可以给Activity指定configChanges属性.指定了configChanges属性后,配置发生变化后,Activity不会重新创建,也没有调用onSaveInstanceState和onRestoreInstanceState来存储和恢复数据,取而代之的是系统调用了Activity的onConfigurationChanged方法.

默认情况下,当我们多次启动同一个Activity的时候,系统会创建多个实例并把它们一一放入任务栈中,当我们单击back键,会发现这些Activity会一一回退.任务栈是一种"后进先出"的栈结构.每按一下back键就会有一个Activity出栈,直到栈空为止,当栈中无任何Activity的时候,系统就会回收这个任务栈.

Activity有四种启动模式:

+ standard,标准模式,这也是系统的默认模式.每次启动一个Activity都会重新创建一个新的实例,不管这个实例是否已经存在.被创建的实例的生命周期符合典型情况下Activity的生命周期.这是一种典型的多实例实现,一个任务栈中可以有多个实例,每个实例也可以属于不同的任务栈.在这种情况下,谁启动了这个Activity,那么这个Activity就运行在启动它的那个Activity所在的栈中.非Activity类型的Context(如ApplicationContext)并没有所谓的任务栈,需要为待启动Activity指定FLAG_ACTIVITY_NEW_TASK标记位,这样启动的时候就会为它创建一个新的任务栈,这个时候
