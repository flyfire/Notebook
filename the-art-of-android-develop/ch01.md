### 1.Activity的生命周期和启动模式

新Activity启动之前,栈顶的Activity需要先onPause之后,新的Activity才能启动.不能在onPause中做重量级的操作,因为必须onPause执行完成以后新Activity才能resume.onPause和onStop都不能执行耗时的操作,尤其是onPause,这也意味着,应当尽量在onStop中做操作,从而使得新Activity尽快显示出来并切换到前台.

在默认情况下,如果我们的Activity不做特殊处理,那么当系统配置发生改变后,Activity就会被销毁并重新创建.当系统配置发生改变后,Activity会被销毁,其onPause,onStop,onDestroy均会被调用,同时由于Activity是在异常情况下终止的,系统会调用onSaveInstanceState来保存当前Activity的状态.这个方法的调用时机是在onStop之前,它和onPause没有既定的时序关系,它既可能在onPause之前调用,也可能在onPause之后调用.需要强调的一点是,这个方法只会出现在Activity被异常终止的情况下,正常情况下系统不会回调这个方法.当Activity被重新创建后,系统会调用onRestoreInstanceState,并且把Activity销毁时onSaveInstanceState方法所保存的Bundle对象作为参数同时传递给onRestoreInstanceState和onCreate方法.因此,可以通过onRestoreInstanceState和onCreate方法来判断Activity是否被重建了,如果被重建了,那么可以取出之前保存的数据并恢复,从时序上来说,onRestoreInstanceState的调用时机在onStart之后.

系统配置中有很多内容,如果当某项内容发生改变后,我们不想系统重新创建Activity,可以给Activity指定configChanges属性.指定了configChanges属性后,配置发生变化后,Activity不会重新创建,也没有调用onSaveInstanceState和onRestoreInstanceState来存储和恢复数据,取而代之的是系统调用了Activity的onConfigurationChanged方法.

默认情况下,当我们多次启动同一个Activity的时候,系统会创建多个实例并把它们一一放入任务栈中,当我们单击back键,会发现这些Activity会一一回退.任务栈是一种"后进先出"的栈结构.每按一下back键就会有一个Activity出栈,直到栈空为止,当栈中无任何Activity的时候,系统就会回收这个任务栈.

Activity有四种启动模式:

+ standard,标准模式,这也是系统的默认模式.每次启动一个Activity都会重新创建一个新的实例,不管这个实例是否已经存在.被创建的实例的生命周期符合典型情况下Activity的生命周期.这是一种典型的多实例实现,一个任务栈中可以有多个实例,每个实例也可以属于不同的任务栈.在这种情况下,谁启动了这个Activity,那么这个Activity就运行在启动它的那个Activity所在的栈中.非Activity类型的Context(如ApplicationContext)并没有所谓的任务栈,需要为待启动Activity指定FLAG_ACTIVITY_NEW_TASK标记位,这样启动的时候就会为它创建一个新的任务栈,这个时候待启动Activity实际上以SingleTask模式启动的。
+ singleTop:栈顶复用模式，在这种模式下，如果新Activity已经位于任务栈的栈顶，那么此Activity不会被重新创建，同时它的onNewIntent方法会被回调，通过此方法的参数我们可以取出当前请求的信息。需要注意的是，这个Activity的onCreate、onStart不会被系统调用，因为它并没有发生改变。如果新Activity的实例已存在但不是位于栈顶，那么新Activity仍然会重新重建。
+ singleTask:栈内复用模式，这时一种单实例模式，在这种模式下，只要Activity在一个栈中存在，那么多次启动此Activity都不会重新创建实例，和singleTop一样，系统也会回调其onNewIntent。具体一点，当一个具有singleTask模式的Activity请求启动后，比如Activity A，系统首先会寻找时分存在A想要的任务栈，如果不存在，就重新创建一个任务栈，然后创建A的实例后把A放到栈中。如果存在A所需的任务栈，这时要看A时分在栈中有实例存在，如果有实例存在，那么系统就会把A调到栈顶病调用它的onNewIntent方法，同时由于singleTask默认具有clearTop效果，会导致栈内所有在A上面的Activity全部出栈。如果实例不存在，就创建A的实例并把A压入栈中。
+ singleInstance:单实例模式，这是一种加强的singleTask模式，它除了具有singleTask模式的所有特性外，还加强了一点，那就是具有此种模式的Activity只能单独地位于一个任务栈中，换句话说，比如Activity A是singleInstance模式，当A启动后，系统会为它创建一个新的任务栈，然后A独自在这个新的任务栈中，由于栈内复用的特性，后续的请求不会创建新的Activity，除非这个独特的任务栈被系统销毁了。
