### 5.理解RemoteViews

PendingIntent表示一种处于pending状态的意图，而pending状态表示的是一种待定、等待、即将发生的意思，就是说接下来有一个Intent将在某个特定的时刻发生。可以看出PendingIntent和Intent的区别在于，PendingIntent是在将来的某个不确定的时刻发生，而Intent是立刻发生。PendingIntent典型的使用场景是给RemoteViews添加单击事件，因为RemoteViews运行在远程进程中，因此RemoteViews不同于普通的View，所以无法直接向View那样通过setOnClickListener方法来设置单击事件。要想给RemoteView设置单击事件，就必须使用PendingIntent，PendingIntent通过send和cancel方法来发送和取消特定的待定Intent。

PendingIntent支持三种待定意图：启动Activity，启动Service和发送广播。

PendingIntent的匹配规则为：如果两个PendingIntent它们内部的Intent相同并且requestCode也相同，那么这两个PendingIntent就是相同的。Intent的匹配规则是：如果两个Intent的ComponentName和intent-filter都相同，那么这两个Intent就是相同的。需要注意的是extras不参与Intent的匹配过程。

PendingIntent的flags：

+ FLAG_ONE_SHOT，当前描述的PendingIntent只能被使用一次，然后它就会被自动cancel，如果后续还有相同的PendingIntent，那么它们的send方法就会调用失败。对于通知栏消息来说，如果采用此标记位，那么同类的通知只能使用一次，后续的通知单击后将无法打开。
+ FLAG_NO_CREATE，当前描述的PendingIntent不会主动创建，如果当前PendingIntent之前不存在，那么getActivity/getService/getBroadcast方法会直接返回null，即获取PendingIntent失败。这个标记位很少见，它无法单独使用。
+ FLAG_CANCEL_CURRENT，当前描述的PendingIntent如果已经存在，那么它们都会被cancel，然后系统会创建一个新的PendingIntent。对于通知栏消息来说，那些被cancel的消息单击后将无法打开。
+ FLAG_UPDATE_CURRENT，当前描述的PendingIntent如果已经存在，那么它们都会被更新，即它们的Intent中的extras会被替换成最新的。

``NotificationManager.notify(id, notification)``如果notify方法的id是常量，那么不管PendingIntent是否匹配，后面的通知会直接替换前面的通知。如果notify方法的id每次都不同，那么当PendingIntent不匹配时，这里的匹配是指PendingIntent中的Intent相同并且requestCode相同，在这种情况下不管采用何种标记位，这些通知之间不会相互干扰。如果PendingIntent处于匹配状态时，这个时候要分情况讨论：如果采用了FLAG_ONE_SHOT标记位，那么后续通知中的PendingIntent会和第一条通知保持完全一致，包括其中的extras，单击任何一条通知后，剩下的通知均无法再打开，当所有的通知都被清除后，会再次重复这个过程；如果采用FLAG_CANCEL_CURRENT标记位，那么只有最新的通知可以打开，之前弹出的所有通知均无法打开；如果采用FLAG_UPDATE_CURRENT标记位，那么之前弹出的通知中的PendingIntent会被更新，最终它们和最新的一条通知保持完全一致，包括其中的extras，并且这些通知都是可以打开的。

RemoteViews目前并不能支持所有的View类型，它所支持的所有类型如下：

+ Layout: ``FrameLayout``,``LinearLayout``,``RelativeLayout``,``GridLayout``
+ View:``AnalogClock``,``Button``,``Chronometer``,``ImageButton``,``ImageView``,``ProgressBar``,``TextView``,``ViewFlipper``,``ListView``,``GridView``,``StackView``,``AdapterViewFlipper``,``ViewStub``.

RemoteViews主要用于通知栏和桌面小部件之中，通知栏和小部件分别由``NotificationManager``和``AppWidgetManager``管理，而``NotificationManager``和``AppWidgetManager``通过Binder分别和SystemServer进程中的NotificationManagerService以及AppWidgetService进行通信。首先``RemoteViews``会通过Binder传递到SystemServer进程，这是因为``RemoteViews``实现了Parcelable接口，因此它可以跨进程传输，系统会根据RemoteViews中的包名等信息去得到该应用的资源。然后会通过LayoutInflater去加载RemoteViews中的布局文件。接着系统会对View执行一系列界面更新任务，这些任务就是之前通过set方法来提交的。set方法对View所做的更新并不是立刻执行的，在RemoteViews内部会记录所有的更新操作，具体的执行时机要等到RemoteViews被加载以后才能执行，这样RemoteViews就可以在SystemServer进程中显示了，这就是我们所看到的通知栏消息或者桌面小部件。当需要更新RemoteViews时，需要调用一系列set方法并通过``NotificationManager``和``AppWidgetManager``来提交更新任务，具体的更新操作也是在SystemServer进程中完成的。

系统没有通过Binder去直接支持View的跨进程访问，而是提供了一个Action的概念，Action代表一个View操作，Action同样实现了Parcelable接口。系统首先将View操作封装到Action对象并将这些对象跨进程传输到远程进程，接着在远程进程中执行Action对象中的具体操作。在我们的应用中每调用一次set方法，RemoteViews中就会添加一个对应的Action对象，当我们通过NotificationManager和AppWidgetManager来提交我们的更新时，这些Action对象就会传输到远程进程并在远程进程中依次执行。

当我们调用RemoteViews的set方法时，并不会立刻更新它们的界面，而必须要通过NotificationManager的notify方法以及AppWidgetManager的updateAppWidget才能更新它们的界面。实际上在AppWidgetManager的updateAppWidget的内部实现中，它们的确是通过RemoteViews的apply以及reapply方法来加载或者更新界面的，apply和reapply的区别在于：apply会加载布局并更新布局，而reapply则只会更新界面。