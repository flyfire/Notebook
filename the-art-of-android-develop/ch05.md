### 5.理解RemoteViews

PendingIntent表示一种处于pending状态的意图，而pending状态表示的是一种待定、等待、即将发生的意思，就是说接下来有一个Intent将在某个特定的时刻发生。可以看出PendingIntent和Intent的区别在于，PendingIntent是在将来的某个不确定的时刻发生，而Intent是立刻发生。PendingIntent典型的使用场景是给RemoteViews添加单击事件，因为RemoteViews运行在远程进程中，因此RemoteViews不同于普通的View，所以无法直接向View那样通过setOnClickListener方法来设置单击事件。要想给RemoteView设置单击事件，就必须使用PendingIntent，PendingIntent通过send和cancel方法来发送和取消特定的待定Intent。

PendingIntent支持三种待定意图：启动Activity，启动Service和发送广播。

PendingIntent的匹配规则为：如果两个PendingIntent它们内部的Intent相同并且requestCode也相同，那么这两个PendingIntent就是相同的。Intent的匹配规则是：如果两个Intent的ComponentName和intent-filter都相同，那么这两个Intent就是相同的。需要注意的是extras不参与Intent的匹配过程。

PendingIntent的flags：

+ FLAG_ONE_SHOT，当前描述的PendingIntent只能被使用一次，然后它就会被自动cancel，如果后续还有相同的PendingIntent，那么它们的send方法就会调用失败。对于通知栏消息来说，如果采用此标记位，那么同类的通知只能使用一次，后续的通知单击后将无法打开。
+ FLAG_NO_CREATE，当前描述的PendingIntent不会主动创建，如果当前PendingIntent之前不存在，那么getActivity/getService/getBroadcast方法会直接返回null，即获取PendingIntent失败。这个标记位很少见，它无法单独使用。
+ FLAG_CANCEL_CURRENT，当前描述的PendingIntent如果已经存在，那么它们都会被cancel，然后系统会创建一个新的PendingIntent。对于通知栏消息来说，那些被cancel的消息单击后将无法打开。
+ FLAG_UPDATE_CURRENT，当前描述的PendingIntent如果已经存在，那么它们都会被更新，即它们的Intent中的extras会被替换成最新的。

``NotificationManager.notify(id, notification)``如果notify方法的id是常量，那么不管PendingIntent是否匹配，后面的通知会直接替换前面的通知。如果notify方法的id每次都不同，那么当PendingIntent不匹配时，这里的匹配是指PendingIntent中的Intent相同并且requestCode相同，在这种情况下不管采用何种标记位，这些通知之间不会相互干扰。如果PendingIntent处于匹配状态时，这个时候要分情况讨论：如果采用了FLAG_ONE_SHOT标记位，那么后续通知中的PendingIntent会和第一条通知保持完全一致，包括其中的extras，单击任何一条通知后，剩下的通知均无法再打开，当所有的通知都被清除后，会再次重复这个过程；如果采用FLAG_CANCEL_CURRENT标记位，那么只有最新的通知可以打开，之前弹出的所有通知均无法打开；如果采用FLAG_UPDATE_CURRENT标记位，那么之前弹出的通知中的PendingIntent会被更新，最终它们和最新的一条通知保持完全一致，包括其中的extras，并且这些通知都是可以打开的。

RemoteViews目前并不能支持所有的View类型，它所支持的所有类型如下：

+ Layout: ``FrameLayout``,``LinearLayout``,``RelativeLayout``,``GridLayout``
+ View:``AnalogClock``,``Button``,``Chronometer``,``ImageButton``,``ImageView``,``ProgressBar``,``TextView``,``ViewFlipper``,``ListView``,``GridView``,``StackView``,``AdapterViewFlipper``,``ViewStub``.

