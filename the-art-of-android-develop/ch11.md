### 11.Android的线程和线程池

AsyncTask封装了线程池和Handler，它主要是为了方便开发者在子线程中更新UI。HandlerThread十一种具有消息循环的线程，在它的内部可以使用Handler。IntentService是一个服务，系统对齐进行了封装使其可以更方便地执行后台任务，IntentService内部采用HandlerThread来执行任务，当任务执行完毕后IntentService会自动退出。从任务执行的角度来看，IntentService的作用很像一个后台线程，但是IntentService是一种服务，它不容易被系统杀死从而可以尽量保证任务的执行，而如果是一个后台线程，由于这个时候进程中没有活动的四大组件，那么这个进程的优先级就会非常低，很容易被系统杀死，这就是IntentService的优点。

HandlerThread的run方法是一个无限循环，因此当明确不需要再使用HandlerThread时，可以通过它的quit或者quitSafely方法来终止线程的执行。

IntentService会通过stopSelf(int startId)方法来尝试立刻停止服务，这里之所以采用stopSelf(int startId)而不是stopSelf()来停止服务，那是因为stopSelf()会立刻停止服务，而这个时候可能还有其他消息未处理，stopSelf(int startId)则会等待所有的消息都处理完毕后才终止服务。一般来说，stopSelf(int startId)在尝试停止服务之前会判断最近启动服务的次数是否和startId相等，如果相等就立刻停止服务，不相等则不停止服务，这个策略可以从AMS的stopServiceToken方法的实现中找到依据。

线程池的优点可以概括为以下三点：

+ 重用线程池中的线程，避免因为线程的创建和销毁所带来的性能开销
+ 能有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致的阻塞现象
+ 能够对线程进行简单的管理，并提供定时执行以及制定间隔循环执行等功能。

```java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
```

+ corePoolSize，线程池的核心线程数，默认情况下，核心线程会在线程池中一直存活，即使它们处于闲置状态。如果将ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，那么闲置的核心线程在等待新任务到来时会有超时策略，这个时间间隔有keepAliveTime所指定，当等待时间超过keepAliveTime所指定的时长后，核心线程就会被终止。
+ maximumPoolSize，线程池所能容纳的最大线程数，当活动线程数达到这个数值后，后续的新任务将会被阻塞。
+ keepAliveTime，非核心线程闲置时的超时时长，超过这个时长，非核心线程就会被回收。当ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true时，keepAliveTime同样会作用于核心线程。
+ workQueue，线程池中的人物队列，通过线程池的execute方法提交的Runnable对象会存储在这个参数中。
+ threadFactory，线程工厂，为线程池提供创建新线程的功能。
+ handler，当线程池无法执行新任务时，这可能是由于任务队列已满或者是无法成功执行任务，这个时候ThreadPoolExecutor会调用handler的rejectedExecution方法来通知调用者，默认情况下rejectedExecution方法会直接抛出一个RejectedExecutionException。ThreadPoolExecutor为RejectedExeceutionHandler提供了几个可选值：CallerRunsPolicy、AbortPolicy、DiscardPolicy和DiscardOldestPolicy，其中AbortPolicy是默认值，它会直接抛出RejectedExecutionException。

ThreadPoolExecutor执行任务时大致遵循如下规则：

+ 如果线程池中的线程数量未达到核心线程的数量，那么会直接启动一个核心线程来执行任务
+ 如果线程池中的线程数量已经达到或者超过核心线程的数量，那么任务会被插入到任务队列中排队等待执行
+ 如果在步骤2中无法将任务插入到任务队列中，这往往是由于任务队列已满，这个时候如果线程数量未达到线程池规定的最大值，那么会立刻启动一个非核心线程来执行任务。
+ 如果步骤3中线程数量已经达到线程池规定的最大值，那么久拒绝执行此任务，ThreadPoolExecutor会调用RejectedExecutionHandler的rejectedExecution方法来通知调用者。