# 2.Java并发机制的底层实现原理

volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可变性”。可变性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。

lock前缀的指令在多核处理器IA-32下会引发两件事情：

+ 将当前处理器缓存行的数据写回到系统内存
+ 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效

Java中的每一个对象都可以作为锁，具体表现为以下3种形式：

+ 对于普通同步方法，锁是当前实例对象
+ 对于静态同步方法，锁是当前类的Class对象
+ 对于同步方法块，锁是synchronized括号里配置的对象。

JVM基于进入和退出monitor对象来实现方法同步和代码块同步。代码块同步是使用monitorenter和monitorexit指令实现的。monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且仅当一个monitor被持有后，它将处于锁定状态。线程执行到monitoreneter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获取对象的锁。

synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽Word存储对象头，如果对象是非数组类型，则用2字宽存储对象头。

Java对象头里的MarkWord里默认存储对象的hashcode、分代年龄和锁标志位。

MarkWord中无锁状态锁标志位为01，是否是偏向锁标志位为0，同时还存储了对象的hashcode和分代年龄。偏向锁锁标志位为01，同时还存储了获取了偏向锁的线程id，以及对象分代年龄等，MarkWord中是否指向偏向锁的标志位也被设置为1。轻量级锁锁标志位为00，同时存储了指向栈中锁记录的指针。重量级锁锁标志位为10，同时存储了指向互斥量（重量级锁）的指针。

Java 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。

大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的MarkWord里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下MarkWord中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。

轻量级锁加锁：线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的MarkWord复制到锁记录中，官方称之为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。

轻量级锁解锁：使用CAS操作将Displaced Mark Word替换回对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。

因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。

|    锁    |                             优点                             |                      缺点                      |                    适用场景                    |
| :------: | :----------------------------------------------------------: | :--------------------------------------------: | :--------------------------------------------: |
|  偏向锁  | 加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 |        适用于只有一个线程访问同步块场景        |
| 轻量级锁 |           竞争的线程不会阻塞，提高了程序的响应速度           | 如果始终得不到锁竞争的线程，使用自旋会消耗CPU  | 追求响应时间，同步块代码比较少，执行速度非常快 |
| 重量级锁 |               线程竞争不使用自旋，不会消耗CPU                |             线程阻塞，响应时间缓慢             |         追求吞吐量，同步块执行时间较长         |

32位IA-32处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。首先，处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存中读取或者写入一个字节是原子的。Pentium6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的，但是复杂的内存操作处理器是不能自动保证其原子性的，比如跨总线宽度、跨多个缓存行和跨页表的访问。但是，处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。

+ 使用总线锁保证原子性。所谓总线锁就是使用处理器提供的一个``Lock #``信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。 
+ 使用缓存锁保证原子性。总线锁定开销太大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言``Lock #``信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。

JVM中的CAS操作利用了处理器提供的CMPXCHG指令实现。

CAS实现原子操作的三大问题：

+ ABA问题。Java 1.5开始，提供了``AtomicStampedReference``来解决ABA问题。
+ 循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。
+ 只能保证一个共享变量的原子操作。从Java1.5开始，提供了``AtomicReference``来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。