# 2.Java并发机制的底层实现原理

volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可变性”。可变性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。

lock前缀的指令在多核处理器IA-32下会引发两件事情：

+ 将当前处理器缓存行的数据写回到系统内存
+ 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效

Java中的每一个对象都可以作为锁，具体表现为以下3种形式：

+ 对于普通同步方法，锁是当前实例对象
+ 对于静态同步方法，锁是当前类的Class对象
+ 对于同步方法块，锁是synchronized括号里配置的对象。

JVM基于进入和退出monitor对象来实现方法同步和代码块同步。代码块同步是使用monitorenter和monitorexit指令实现的。monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且仅当一个monitor被持有后，它将处于锁定状态。线程执行到monitoreneter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获取对象的锁。

synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽Word存储对象头，如果对象是非数组类型，则用2字宽存储对象头。

Java对象头里的MarkWord里默认存储对象的hashcode、分代年龄和锁标志位。

MarkWord中无锁状态锁标志位为01，是否是偏向锁标志位为0，同时还存储了对象的hashcode和分代年龄。偏向锁锁标志位为01，同时还存储了获取了偏向锁的线程id，以及对象分代年龄等，MarkWord中是否指向偏向锁的标志位也被设置为1。轻量级锁锁标志位为00，同时存储了指向栈中锁记录的指针。重量级锁锁标志位为10，同时存储了指向互斥量（重量级锁）的指针。

Java 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。