# 4.Java并发编程基础

现代操作系统调度的最小单位为线程，也叫轻量级进程（Light Weight Process），在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能访问共享的内存变量。

Java线程在运行时的生命周期。

| 状态名称     | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| NEW          | 初始状态，线程被构建，但是还没有调用start()方法              |
| RUNNABLE     | 运行状态，Java线程将操作系统中的就绪和运行两种状态笼统地称作“运行中” |
| BLOCKED      | 阻塞状态，表示线程阻塞于锁                                   |
| WAITING      | 等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断） |
| TIME_WAITING | 超时等待状态，该状态不同于WAITING，它是可以在指定的时间自行返回的 |
| TERMINATED   | 终止状态，表示当前线程已经执行完毕                           |

Daemon线程是一种支持型线程，以为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。可以在启动线程之前通过调用``Thread.setDaemon(true)``将线程设置为Daemon线程。

中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。中断好比其他线程对该线程打了个招呼，其他线程通过调用该线程的interrupt()方法对其进行中断操作。

线程通过检查自身是否被中断来进行响应，线程通过方法``isInterrupted()``来进行判断是否被中断，也可以调用静态方法``Thread.interrupted()``对当前线程的中断标识位进行复位。

中断状态是线程的一个标识位，而中断操作是一种简便的线程间交互方式，而这种交互方式最适合用来取消或停止任务。除了中断以外，还可以利用一个boolean变量来控制是否需要停止任务并终止该线程。

关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对共享变量访问的可见性。

对于同步块的实现使用了monitorenter和monitorexit指令，而同步方法则是依靠方法修饰符上的ACC_SYNCHRONIZED来完成的。无论采用哪种方式，其本质是对一个对象的监视器(monitor)进行获取，而这个获取过程是排他的，也就是同一时刻只能有一个线程获取到由synchronized所保护对象的监视器。

任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或同步方法，而没有获取到监视器的线程将会被阻塞在同步块或同步方法的入口处，进入BLOCKED状态。

等待、通知的相关方法

| 方法名称       | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| notify()       | 通知一个在对象上等待的线程，使其从wait()方法返回，而返回的前提是该线程获取到了 |
| notifyAll()    | 通知所有等待在该对象上的线程                                 |
| wait()         | 调用该方法的线程进入WAITING状态，只有等待另外线程的通知或被中断才返回，需要注意的是，调用wait()方法后，会释放对象的锁 |
| wait(long)     | 超时等待一段时间，这里的参数时间是毫秒，也就是等待n毫秒，如果没有通知就超时返回 |
| wait(long,int) | 对于超时时间更细粒度的控制，可以达到纳秒                     |

调用wait()、notify()以及notifyAll()时需要注意的细节：

+ 使用wait()、notify()和notifyAll()时需要先对调用对象加锁
+ 调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列
+ notify()或notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或notifyAll()的线程释放锁之后，等待线程才有机会从wait()返回
+ notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll()方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由WAITING变为BLOCKED。
+ 从wait()方法返回的前提是获得了调用对象的锁

等待通知的经典范式，该范式分为两部分，分别针对等待方（消费者）和通知方（生产者）。

等待方遵循如下原则：

+ 获取对象的锁

+ 如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件

+ 条件满足时则执行对应的逻辑

```java
synchronized(对象) {

    while(条件不满足) {

        对象.wait();

    }

    对应的处理逻辑

}
```

通知方遵循如下原则：

+ 获得对象的锁

+ 改变条件

+ 通知所有等待在对象上的线程

```java
synchronized(对象) {

    改变条件

    对象.notifyAll();

}
```

如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis,int nanos)连个具备超时特性的方法。这两个超时方法表示，如果线程thread在给定超时时间里没有终止，那么将会从该超时方法中返回。

``ThreadLocal``，即线程变量，是一个以``ThreadLocal``对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个``ThreadLocal``对象查询到绑定在这个线程上的一个值。

等待超时模式

```java
// 对当前对象加锁
public synchronized Object get(long mills) throws InterruptedException {
    long future = System.currentTimeMillis() + mills;
    long remaining = mills;
    while ((result == null) && remaining > 0) {
        wait(remaining);
        remaining = future - System.currentTimeMillis();
    }
    return result;
}
```

