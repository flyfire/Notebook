# 5.Java中的锁

在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而Java 1.5之后，JUC中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。虽然它缺少了（通过synchronized块或方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。

Lock的使用也很简单。

```java
Lock lock = new ReentrantLock();
lock.lock();
try {
    // do sth
} finally {
    lock.unlock();
}
```

不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放。

Lock接口提供的synchronized关键字所不具备的主要特性。

| 特性               | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| 尝试非阻塞地获取锁 | 当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁 |
| 能被中断地获取锁   | 与synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放 |
| 超时获取锁         | 在指定的截止时间之前获取锁，如果截止时间到了仍旧无法获取锁，则返回。 |

Lock是一个接口，它定义了锁获取与释放的基本操作。

| 方法名称                                                     | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| void lock()                                                  | 获取锁，调用该方法当前线程将会获取锁，当锁获得后，从该方法返回 |
| void lockInterruptibly() throws InterruptedException         | 可中断地获取锁，和lock()方法的不同之处在于该方法会响应中断，即在锁的获取中可以中断当前线程 |
| boolean tryLock()                                            | 尝试非阻塞的获取锁，调用该方法后立即返回，如果能够获取则返回true，否则返回false |
| boolean tryLock(long time,TimeUnit unit) throws InterruptedException | 超时的获取锁，当前线程在以下3种情况下返回：1.当前线程在超时时间内获取了锁 2.当前线程在超时时间内被中断 3.超时时间结束，返回false |
| void unlock()                                                | 释放锁                                                       |
| Condition neCondition()                                      | 获取等待通知组件，该组件与当前的锁绑定，当前线程只有获取了锁，才能调用该组件的wait()方法，而调用后，当前线程将释放锁 |

AQS是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。

AQS的主要使用方式是继承，子类通过继承AQS并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用AQS提供的3个方法``getState()``，``setState(newState)``和``compareAndSetState(int expect, int update)``来进行操作，因为它们能够保证状态的改变是安全的。

子类被推荐定义为自定义同步组件的静态内部类，AQS自身没有实现任何同步接口，它仅仅定义了若干同步状态获取和释放的方法来供自定义同步组件使用，AQS既可以支持独占式地获取同步状态，也支持共享式地获取同步状态。

AQS是实现同步组件的关键，在同步组件的实现中聚合AQS，利用AQS实现锁的语义。

AQS的设计是基于模板方法模式的，也就是说，使用者需要继承AQS并重写指定的方法，随后将AQS组合在自定义同步组件的实现中，并调用AQS提供的模板方法，而这些模板方法将会调用使用者重写的方法。

重写AQS指定的方法时，需要使用AQS提供的如下3个方法来访问或修改同步状态：

+ ``getState()``：获取当前同步状态
+ ``setState(int newState)``：设置当前同步状态
+ ``compareAndSetState(int expect, int update)``:使用CAS设置当前状态，该方法能保证状态设置的原子性。

AQS可重写的方法与描述如下：

| 方法名称                                    | 描述                                                         |
| ------------------------------------------- | ------------------------------------------------------------ |
| protected boolean tryAcquire(int arg)       | 独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态十分符合预期，然后再进行CAS设置同步状态 |
| protected boolean tryRelease(int arg)       | 独占式地释放同步状态，等待获取同步状态的线程将有机会获取同步状态 |
| protected int tryAcquireShared(int arg)     | 共享式地获取同步状态，返回大于0的值，表示获取成功，反之，获取失败 |
| protected boolean tryReleaseShared(int arg) | 共享式释放同步状态                                           |
| protected boolean isHeldExclusively()       | 当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占 |

