# 5.Java中的锁

在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而Java 1.5之后，JUC中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。虽然它缺少了（通过synchronized块或方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。

Lock的使用也很简单。

```java
Lock lock = new ReentrantLock();
lock.lock();
try {
    // do sth
} finally {
    lock.unlock();
}
```

不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放。

Lock接口提供的synchronized关键字所不具备的主要特性。

| 特性               | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| 尝试非阻塞地获取锁 | 当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁 |
| 能被中断地获取锁   | 与synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放 |
| 超时获取锁         | 在指定的截止时间之前获取锁，如果截止时间到了仍旧无法获取锁，则返回。 |

Lock是一个接口，它定义了锁获取与释放的基本操作。

| 方法名称                                                     | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| void lock()                                                  | 获取锁，调用该方法当前线程将会获取锁，当锁获得后，从该方法返回 |
| void lockInterruptibly() throws InterruptedException         | 可中断地获取锁，和lock()方法的不同之处在于该方法会响应中断，即在锁的获取中可以中断当前线程 |
| boolean tryLock()                                            | 尝试非阻塞的获取锁，调用该方法后立即返回，如果能够获取则返回true，否则返回false |
| boolean tryLock(long time,TimeUnit unit) throws InterruptedException | 超时的获取锁，当前线程在以下3种情况下返回：1.当前线程在超时时间内获取了锁 2.当前线程在超时时间内被中断 3.超时时间结束，返回false |
| void unlock()                                                | 释放锁                                                       |
| Condition neCondition()                                      | 获取等待通知组件，该组件与当前的锁绑定，当前线程只有获取了锁，才能调用该组件的wait()方法，而调用后，当前线程将释放锁 |

AQS是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。

AQS的主要使用方式是继承，子类通过继承AQS并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用AQS提供的3个方法``getState()``，``setState(newState)``和``compareAndSetState(int expect, int update)``来进行操作，因为它们能够保证状态的改变是安全的。

子类被推荐定义为自定义同步组件的静态内部类，AQS自身没有实现任何同步接口，它仅仅定义了若干同步状态获取和释放的方法来供自定义同步组件使用，AQS既可以支持独占式地获取同步状态，也支持共享式地获取同步状态。

AQS是实现同步组件的关键，在同步组件的实现中聚合AQS，利用AQS实现锁的语义。

AQS的设计是基于模板方法模式的，也就是说，使用者需要继承AQS并重写指定的方法，随后将AQS组合在自定义同步组件的实现中，并调用AQS提供的模板方法，而这些模板方法将会调用使用者重写的方法。

重写AQS指定的方法时，需要使用AQS提供的如下3个方法来访问或修改同步状态：

+ ``getState()``：获取当前同步状态
+ ``setState(int newState)``：设置当前同步状态
+ ``compareAndSetState(int expect, int update)``:使用CAS设置当前状态，该方法能保证状态设置的原子性。

AQS可重写的方法与描述如下：

| 方法名称                                    | 描述                                                         |
| ------------------------------------------- | ------------------------------------------------------------ |
| protected boolean tryAcquire(int arg)       | 独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态十分符合预期，然后再进行CAS设置同步状态 |
| protected boolean tryRelease(int arg)       | 独占式地释放同步状态，等待获取同步状态的线程将有机会获取同步状态 |
| protected int tryAcquireShared(int arg)     | 共享式地获取同步状态，返回大于0的值，表示获取成功，反之，获取失败 |
| protected boolean tryReleaseShared(int arg) | 共享式释放同步状态                                           |
| protected boolean isHeldExclusively()       | 当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占 |

实现自定义同步组件时，将会调用AQS的模板方法，部分模板方法和描述如下：

| 方法名称                                          | 描述                                                         |
| ------------------------------------------------- | ------------------------------------------------------------ |
| void acquire(int arg)                             | 独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步队列等待，该方法将会调用重写的``tryAcquire(int arg)``方法 |
| void acquireInterruptibly(int arg)                | 与acquire(int arg)相同，但是该方法响应中断，当前线程未获取到同步状态而进入同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException并返回 |
| boolean tryAcquireNanos(int arg,long nanos)       | 在acquireInterruptibly(int arg)基础上增加了超时机制，如果当前线程在超时时间内没有获取到同步状态，那么将会返回false，如果获取到了返回true |
| void acquireShared(int arg)                       | 共享式的获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式获取的主要区别是在同一时刻可以有多个线程获取到同步状态 |
| void acquireSharedInterruptibly(int arg)          | 与acquireShared(int arg)相同，该方法响应中断                 |
| boolean tryAcquireSharedNanos(int arg,long nanos) | 在acquireSharedInterruptibly(int arg)基础上增加了超时限制    |
| boolean release(int arg)                          | 独占式的释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒 |
| boolean releaseShared(int arg)                    | 共享式的释放同步状态                                         |
| Collection<Thread> getQueuedThreads()             | 获取等待在同步队列上的线程集合                               |

AQS依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造称为一个节点Node并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。

同步队列中的节点Node用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点，节点的属性类型与名称以及描述如下：

| 属性类型和名称  | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| int waitStatus  | 等待状态，包含如下状态：(1)CANCELLED，值为1，由于在同步队列中等待的线程等待超时或者被中断，需要从同步队列中取消等待，节点进入该状态将不会变化(2)SIGNAL，值为-1，后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或取消了等待，将会通知后继节点，使后继节点的线程得以运行(3)CONDITION，值为-2，节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()方法后，该节点将会从等待队列中装移到同步队列中，加入到对同步状态的获取中(4)PROPAGATE，值为-3，表示下一次共享式同步状态获取将会无条件地被传播下去(5)INITIAL，值为0，初始状态 |
| Node prev       | 前驱节点，当节点加入同步队列时被设置（尾部添加）             |
| Node next       | 后继节点                                                     |
| Node nextWaiter | 等待队列中的后继节点。如果当前节点是共享的，那么这个字段将是一个SHARED常量，也就是说节点类型（独占和共享）和等待队列中的后继节点共用同一个字段 |
| Thread thread   | 获取同步状态的线程                                           |

节点是构成同步队列的基础，AQS持有首节点head和尾节点tail，没有成功获取同步状态的线程将会成为节点加入该队列的尾部。

当一个线程成功地获取了同步状态（或锁），其他线程将无法获取到同步状态，转而被构造成为节点并加入同步队列中，这个加入队列的过程必须要保证线程安全，AQS提供了一个基于CAS的设置尾节点的方法：``compareAndSetTail(Node expect, Node update)``，它需要传递当前线程认为的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。

同步队列遵循FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。设置首节点是通过获取同步状态成功的线程完成的，由于只有一个线程能够成功获取到同步状态，因此设置头结点的方法并不需要使用CAS来保证，它只需要将首节点设置成为原首节点的后继节点并断开原首节点的next引用即可。

ReadWriteLock仅定义了获取读锁和写锁的两个方法，即readLock()方法和writeLock()方法，而其实现ReentrantReadWriteLock除了接口方法之外，还提供了一些便于外界监视器内部工作状态的方法。

| 方法名称                | 描述                                                         |
| ----------------------- | ------------------------------------------------------------ |
| int getReadLockCount()  | 返回当前读锁被获取的次数。该次数不等于获取读锁的线程数，因为有线程重入 |
| int getReadHoldCount()  | 返回当前线程获取读锁的次数。该方法在Java 6中加入到ReentrantReadWriteLock中，使用ThreadLocal保存当前线程获取的次数，这也使得Java 6的实现变得更加复杂 |
| boolean isWriteLocked() | 判断写锁是否被获取                                           |
| int getWriteHoldCount() | 返回当前写锁被获取的次数                                     |

读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。在ReentrantLock中自定义同步器的同步状态表示一个锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态（一个int变量）上维护多个读线程和一个写线程的状态。如果在一个int变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写。假设当前同步状态是S，写状态等于S&0x0000FFFF，读状态等于S>>>16(无符号补0右移16位)。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1<<16)，也就是S+0x00010000。根据状态的划分能得出一个推论：S不等于0时，当写状态(S&0x0000FFFF)等于0时，则读状态(S>>>16)大于0，即读锁已被获取。

如果存在读锁，则写锁不能被获取，原因在于：读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。

锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放先前拥有的写锁的过程。锁降级中读锁的获取是否必要呢？答案是必要的。主要是为了保证数据的可见性，如果当前不获取读锁而是直接释放写锁，假设此时另一个线程T获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。

LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread thread)方法来唤醒一个被阻塞的线程。

| 方法名称                      | 描述                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| void park()                   | 阻塞当前线程，如果调用unpark(Thread thread)方法或者当前线程被中断，才能从park()方法返回 |
| void parkNanos(long nanos)    | 阻塞当前线程，最长不超过nanos纳秒，返回条件在park()的基础上增加了超时返回 |
| void parkUntil(long deadline) | 阻塞当前线程，直到deadline时间                               |
| void unpark(Thread thread)    | 唤醒处于阻塞状态的线程thread                                 |

Java6中，LockSupport增加了park(Object blocker)、parkNanos(Object blocker,long nanos)和parkUntil(Object blocker, long deadline)3个方法，用于实现阻塞当前线程的功能，其中参数blocker是用来标识当前线程在等待的对象，该对象主要用于问题排查和系统监控。

| 对比项                                               | Object Monitor Methods | Condition                                                    |
| ---------------------------------------------------- | ---------------------- | ------------------------------------------------------------ |
| 前置条件                                             | 获取对象的锁           | 调用Lock.lock()获取锁，调用lock.newCondition()获取Condition对象 |
| 调用方式                                             | 直接调用如obj.wait()   | 直接调用如condition.await();                                 |
| 等待队列个数                                         | 一个                   | 多个                                                         |
| 当前线程释放锁并进入等待状态                         | 支持                   | 支持                                                         |
| 当前线程释放锁并进入等待状态，在等待状态中不响应中断 | 不支持                 | 支持                                                         |
| 当前线程释放锁并进入超时等待状态                     | 支持                   | 支持                                                         |
| 当前线程释放锁并进入等待状态到将来某个时刻           | 不支持                 | 支持                                                         |
| 唤醒等待队列中的一个线程                             | 支持                   | 支持                                                         |
| 唤醒等待队列中的全部线程                             | 支持                   | 支持                                                         |

