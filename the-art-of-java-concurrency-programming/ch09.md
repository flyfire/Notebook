# 9.Java中的线程池

提交一个任务到线程池时，线程池的处理流程如下：

+ 线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。
+ 线程池判断工作队列是否已满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。
+ 线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。

ThreadPoolExecutor执行execute方法分下面4种情况：

+ 如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）
+ 如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。
+ 如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）
+ 如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将交给饱和策略来处理。

RejectExecutionHandler(饱和策略)

+ AbortPolicy：直接抛出异常
+ CallerRunsPolicy：调用者线程来运行任务
+ DiscardOldestPolicy：丢弃队列中最近的一个任务，并执行当前任务
+ DiscardPolicy：不处理，丢弃掉

关闭线程池：可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true，当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminated方法会返回true。