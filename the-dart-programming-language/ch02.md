在Dart中，一切皆对象，这甚至包括了最简单的数据如数字或布尔值true和false等。

``accessor``是为方便访问值所提供的特殊方法。

Dart提供的``getter``方法是一个不带参数的特殊方法，可以在不提供参数列表的情况下直接调用。``getter``方法的引入是通过在方法名前添加前缀``get``。

``getter``的调用语法与变量的访问没有区别。Dart中所有变量的访问，实际上都是调用``getter``。每个实例变量始终有一个与之关联的``getter``，由Dart编译器提供。``setter``方法名前面要添加前缀``set``，并只接收一个参数。``setter``的调用语法与传统的变量赋值一样。如果一个实例变量是可变的，则一个``setter``将自动为它定义，所有实例变量的赋值实际上都是对``setter``的调用。

Dart会将每个新分配的变量（不只是实例变量，还包括局部变量、类变量和顶层变量）初始化为``null``。在Dart中，``null``也是一个对象。

声明实例或静态变量会自动引入一个``getter``。如果变量是可变的，则一个``setter``也会自动定义。事实上，Dart中字段都不是直接访问的，所有对字段的引用都是对``accessor``方法的调用。只有对象的``accessor``才能直接访问它的状态，所有访问对象状态的代码都必须通过这些``accessor``方法。

类变量通常也被称为静态变量，但静态变量这个术语也包括了类变量与顶层变量。类变量是延迟初始化的，在``getter``第一次被调用时类变量才执行初始化，即第一次尝试读取它时。与其他变量一样，如果一个类变量没有被初始化，则它默认初始化为``null``。类变量的延迟初始化有助于避免一个典型的问题：过量的前期初始化导致应用程序启动缓慢。

Dart的变量可以用``final``作为前缀，表明它们在初始化后不能再修改。``final``字段有``getter``但是没有``setter``。``final``类变量必须在声明时就进行初始化。

所有的对象都支持相等操作符``==``。这个操作符是在``Object``类中定义的。

所有Dart对象都支持一个名为``hashCode``的``getter``方法。对象的相等和``hashCode``是相互关联的。

如果子类声明一个与父类的某个方法同名的实例方法，那么可以说成子类重写了父类的方法。重写并不总是合法的。你不能用一个普通方法重写``getter``，反之亦然。这些情况会导致编译错误。 // todo 看完反射后再看编译器默认生成了什么方法，暂且放下

通常来说，简单地声明一个方法而不提供它的实现是有用的，这种方法被称为抽象方法。任何种类的实例方法都可以是抽象的，不管它是``getter``、``setter``、操作符或普通的方法。

每个类都隐含地定义了一个接口，此接口描述了类的实例拥有哪些方法。很多编程语言都有正式的接口声明，但在Dart中没有，这是不必要的，因为我们始终可以定义一个抽象类来描述所需的接口。

初始化实例变量的几种方式，可以在实例变量声明时进行初始化，或者使用构造函数的初始化方式，或者通过初始化列表，或者在构造函数中初始化。

初始化操作用逗号隔开，并从左到右执行。除了初始化实例变量外，初始化李彪也可以包含一个父类构造函数的调用。如果初始化列表中没有调用父构造函数，那么一个隐含的父构造函数``super()``将会被添加到初始化列表的尾部。

常量对象的创建是使用``const``而不是``new``。同``new``表达式一样，``const``表达式也是调用构造函数，但该构造函数必须是常量构造函数，而且他的参数必须是常量。实际上，Dart要求常量构造函数的参数必须是数字、布尔值或者字符串。我们并不踪需要创建常量。事实上，我们仍然可以使用``new``调用常量构造函数。如果我们那样做，则我们传递的参数不再受限制，但结果不再是常量。

有一点需要牢记，类变量从不被继承，类方法永远不会被继承。

每个Dart类都有一个mixin，这个mixin是在类主体中定义的特定功能。我们把mixin应用看作用一个mixin与一个父类来派生一个新类。Dart支持基于mixin的继承：每个类都引入了一个mixin，它捕获了类本身对类层次结构所做的独特贡献。mixin使类的代码以模块化方式重用，而不依赖于它在类层次结构中的位置。