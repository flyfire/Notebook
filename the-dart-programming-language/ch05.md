一门语言之所以被称为类型可选，仅当以下条件成立时：

+ 类型在语法层面是可选的
+ 类型对运行时语义没有影响

如果程序中的变量没有显式地给予类型，则它的类型就是``dynamic``。``dynamic``类型是一种特殊的类型，它告知类型检查器不要对变量本身的操作或给变量赋值等行为发出警告。相比之下，显式使用类型``Object``，意味着我们真正期望此变量中的每个对象都必须是有效的值。这两种情况看起来类似，但当我们对``Object``类型的表达式进行操作时，如果尝试使用不被所有对象支持的方法，则我们会得到警告。相反，使用类型``dynamic``能有效地使静态类型检查安静下来，它告诉类型检查器，我们明确知道自己在做什么。

Dart的接口类型给对象定义了一组可用的方法。Dart并没有声明接口的语法，接口是通过类声明引入的。每个类都引入了一个隐性接口，其签名是基于类的成员。对于传统接口声明的需求，我们定义一个纯抽象类就可以轻松解决。任何类都可以实现一个接口，即使该接口与类完全没有关联。

类不会继承implements子句内任何接口的实现，implements子句所做的，是使类与它所列出的接口建立明确的子类关系。这种关系会影响Dart类型检查器及运行时的行为。

当对象从一个变量传递到另一个变量时，会触发类型检查。这样的值传递发生于：

+ 执行赋值操作
+ 传递实参给函数
+ 函数返回结果

严格来说，在值传递的过程中，类型检查器并不强制要求变量之间有父接口关系。它检查的是可赋值性。可赋值性比继承关系更宽松。只要两个类型之间存在父子关系，Dart就认为它们可以**相互赋值**。

Dart的类可以是泛化的，也就是说，它们能通过类型进行参数设置。泛型类可以指定实际的类型参数：``List<String> l;``这种类型被称为参数化类型。但是，给泛型类提供类型参数并不是必须的，如果我们选择使用泛型类且不提供类型参数，则类型``dynamic``类型将会被隐性使用，代替所有缺失的类型参数。

如果提供了错误数量的类型参数，则所有的类型参数都将失效。``Map<String> m ``将引发一个静态警告，除了警告，它会被视为``Map<dynamic,dynamic>``

在Dart中，``List<Apple>``确实是一个``List<Fruit>``。更普遍的说法，如果G是一个由n个类型参数的泛型类，而Si是Ti的子类型，那么G<S1,...,Sn> <: G<T1,...,Tn>，其中T<:S表示T是S的子类型。这种行为被称为协变。

给定Ft和Fs=(S1,..,Sn)->S两个函数类型，在什么情况下可以说Ft是Fs的子类型呢？

类型理论告诉我们，上述论点成立的条件是T是S的子类型，而Si是Ti的子类型。即Fs的每个形式参数都必须是Ft中对应参数的子类型。需要注意的是，子类型关系的方向是反转的，这种现象被称为逆变，其中的