在Dart中，整数可以是任意大小。

浮点数（双精度）是依照IEEE754标准实现的64bit浮点数字。浮点数是dart:core库中double类的实例。大多数情况下，如果两个浮点数相等，则它们形同，但是有两个例外：

+ 浮点数-0.0和0.0相等但不相同
+ NaN与自身不相同但相等。

不像其他语言，不能将任意表达式强制转换为布尔值。Dart不支持内置的强制转换。

Dart还支持原始字符串，原始字符串不支持转义序列，它们包含的内容完全等同于引号之间的字符。

Dart使用UTF-16的编码单元来表示字符串。Dart核心库包含了可以将字符串转换为unicode的Runes类。

列表字面量通常写成封闭在方括号内的一系列用逗号分隔的表达式。所有列表字面量都实现了类List的接口。可以方便地把字面量[]看做new List()的缩写。

``[1,2,3]``等价于``new List()..add(1)..add(2)..add(3);``。Dart不会尝试从列表的元素推断更精确的类型。一个原因是这样的类型推导在运行时非常昂贵，另一个原因是可选类型。

``<int>[1,2,3]``等价于``new List<int>..add(1)..add(2)..add(3);``

通过添加保留字前缀const，列表字面量能够变为编译时常量。

所有map字面量都实现了Map类的接口。``{'a':1, 'b': 2, 'c': 3}``创建的是``Map<dynamic, dynamic>``，可以选择写为``<String,int>{'a':1, 'b':2, 'c':3}``来显式地提供类型参数。

标识符不能是保留字。对于在程序中永远不会被用来命名实体的保留字和内置标识符，Dart是区别对待的。这些是Dart的保留字：``assert``，``break``，``case``，``catch``，``class``，``const``，``continue``，``default``，``do``，``else``，``enum``，``extends``，``false``，``final``，``finally``，``for``，``if``，``in``，``is``，``new``，``null``，``rethrow``，``return``，``super``，``switch``，``this``，``throw``，``true``，``try``，``var``，``void``，``while``，``with``。而这些是内置标识符：``abstract``，``as``，``deferred``，``dynamic``，``export``，``factory``，``get``，``implements``，``import``，``library``，``operator``，``part``，``set``，``static``，``typedef``。

常量表达式是可以在编译时被求值的表达式。常量表达式的值永远无法改变。常量包括数字字面量、布尔、null、列表和map常量、顶层函数、静态方法、常量对象和一些子部分是常量的特殊复合表达式。

常量对象的创建是将实例创建表达式中的new替换为const。常量对象只能在非常特殊的情况下才能创建。当前类必须有一个合法的const构造函数，且构造函数的参数本身必须是常量。

赋值可以对顶层、类、实例和局部变量执行。对于顶层、类和实例变量，赋值是调用一个setter的语法糖。对于局部变量，赋值的执行方式与传统语言是一样的，即将赋值右边变量的值设置为左边表达式的求值结果。

方法调用的形式是``e.m(args)``，其中e是产生一个对象的表达式，m是一个对象成员的名称，args是一个可能为空的参数列表。

在访问成员时，接收者先被计算，然后是方法的参数。在所有的函数调用时，参数都是从左到右计算的。Dart中的运算符本质上是有着特殊语法的实例方法。有部分运算符是受限的，它们不能被用户的代码重新定义，但它们大部分被当作普通的实例方法，可以在任意类中被声明或者重写。

形如``throw e``的表达式将抛出一个异常。抛出的异常是子表达式e的求值结果。与其他语言不一样，throw是表达式，不是语句。Dart中的任意对象都可以被作为异常抛出。被抛出的对象并没有要求是某个特殊异常类的实例或者子类。

try语句由多个部分组成。首先是一条可能抛出异常的语句，该语句紧跟在try关键字之后。之后，可能有一或多个catch子句，一个finally子句，或两者皆有。catch子句为特定类别的异常定义处理逻辑，finally子句用于定义始终执行的清理代码。

捕获到异常是比较常见的，在检查之后发现本地不需要处理时，异常应该在调用链中继续向上传播。rethrow语句就是处理这种情况的，它在catch子句中将捕获的异常重新抛出。

switch语句提供了一种基于表达式的值从若干case中选择行动方案的方式。switch语句的每个case都对应该表达式的一个可能值。必须预先知晓表达式的可能值，它们必须是编译时常量，而且每种情况的类型也要一致。

switch语句有许多要求，各种case都必须是编译时常量，这使得编译更有效，而且，这些常量必须符合以下条件之一：

+ 都是int的实例
+ 都是String的实例
+ 都是同一个类的实例切该类必须从Object继承了==的实现

assert断言在生产模式下它是被关闭的，在空间和时间上都不会带来开销。它只在检查模式下生效。

return语句将控制从函数转交给它的调用者。如果return被try-finally语句包围，则控制会转交给finally子句。

在生产型构造函数中，return语句是被特殊对待的。带有表达式的return语句不允许出现在生产构造函数中。在生产构造函数中，允许不带表达式的return，会被解析为return this，而不是return null。

yield语句被用于生成器函数内，目的是给生成的集合添加新的结果。yield语句的形式是``yield e;``。yield语句总是使它的表达式被求值。通常情况下，求值结果会被追加到外层生成器所关联的集合中。如果生成器是同步的，则关联的集合是一个``iterable``，如果是异步的，则关联的集合是一个``stream``。除了上面这点，yield也会因外层的生成器是否同步而产生不同的行为。在同步的情况下，yield会暂停外层的生成器，对``moveNext()``的调用会使生成器继续执行，且它的返回值为true。在异步情况下，生成器的执行会继续。yield语句只能在生成器中使用。

yield-each语句的形式为``yield* e;``，表达式e的值必须是一个集合，否则将产生运行时错误，``yield*``将e的所有元素追加到外层生成器关联的集合中。