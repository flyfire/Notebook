[A tour of the Dart language](https://dart.dev/guides/language/language-tour)

Dart 2.3 introduced the **spread operator** (`...`) and the **null-aware spread operator** (`...?`), which provide a concise way to insert multiple elements into a collection.

Dart 2.3 also introduced **collection if** and **collection for**, which you can use to build collections using conditionals (`if`) and repetition (`for`).

Although the Set *type* has always been a core part of Dart, set *literals* were introduced in Dart 2.2.

To create an empty set, use `{}` preceded by a type argument, or assign `{}` to a variable of type `Set`:

```dart
var names = <String>{};
// Set<String> names = {}; // This works, too.
// var names = {}; // Creates a map, not a set.
```

 As of Dart 2, the `new` keyword is optional.

In Dart, runes are the UTF-32 code points of a string.Unicode defines a unique numeric value for each letter, digit, and symbol used in all of the world’s writing systems. Because a Dart string is a sequence of UTF-16 code units, expressing 32-bit Unicode values within a string requires special syntax.

A [Symbol](https://api.dartlang.org/stable/dart-core/Symbol-class.html) object represents an operator or identifier declared in a Dart program. You might never need to use symbols, but they’re invaluable for APIs that refer to identifiers by name, because minification changes identifier names but not identifier symbols.To get the symbol for an identifier, use a symbol literal, which is just `#` followed by the identifier:`#radix`.Symbol literals are compile-time constants.

The `=> *expr*` syntax is a shorthand for `{ return *expr*; }`. The `=>` notation is sometimes referred to as *arrow* syntax.

[Required](https://pub.dev/documentation/meta/latest/meta/required-constant.html) is defined in the [meta](https://pub.dev/packages/meta) package. Either import `package:meta/meta.dart` directly, or import another package that exports `meta`, such as Flutter’s `package:flutter/material.dart`.

Old code might use a colon (`:`) instead of `=` to set default values of named parameters. The reason is that originally, only `:` was supported for named parameters. That support is likely to be deprecated, so we recommend that you **use = to specify default values.**

Every app must have a top-level `main()` function, which serves as the entrypoint to the app. The `main()`function returns `void` and has an optional `List<String>` parameter for arguments.

The `..` syntax in the preceding code is called a [cascade](https://dart.dev/guides/language/language-tour#cascade-notation-). With cascades, you can perform multiple operations on the members of a single object.

For operators that work on two operands, the leftmost operand determines which version of the operator is used. For example, if you have a Vector object and a Point object, `aVector + aPoint` uses the Vector version of +.

```dart
// Assign value to b if b is null; otherwise, b stays the same
b ??= value;
```

```dart
expr1 ?? expr2  //If expr1 is non-null, returns its value; otherwise, evaluates and returns the value of expr2.
String playerName(String name) => name ?? 'Guest';
```

Cascades (`..`) allow you to make a sequence of operations on the same object. In addition to function calls, you can also access fields on that same object. This often saves you the step of creating a temporary variable and allows you to write more fluid code.Strictly speaking, the “double dot” notation for cascades is not an operator. It’s just part of the Dart syntax.

Switch statements in Dart compare integer, string, or compile-time constants using `==`. The compared objects must all be instances of the same class (and not of any of its subtypes), and the class must not override `==`.[Enumerated types](https://dart.dev/guides/language/language-tour#enumerated-types) work well in `switch` statements.

Assert statements have no effect in production code; they’re for development only. Flutter enables asserts in [debug mode.](https://flutter.dev/docs/testing/debugging#debug-mode-assertions) Development-only tools such as [dartdevc](https://dart.dev/tools/dartdevc) typically support asserts by default. Some tools, such as [dart](https://dart.dev/server/tools/dart-vm) and [dart2js,](https://dart.dev/tools/dart2js) support asserts through a command-line flag: `--enable-asserts`.

Your Dart code can throw and catch exceptions. Exceptions are errors indicating that something unexpected happened. If the exception isn’t caught, the isolate that raised the exception is suspended, and typically the isolate and its program are terminated.

In contrast to Java, all of Dart’s exceptions are unchecked exceptions. Methods do not declare which exceptions they might throw, and you are not required to catch any exceptions.

Dart provides [Exception](https://api.dartlang.org/stable/dart-core/Exception-class.html) and [Error](https://api.dartlang.org/stable/dart-core/Error-class.html) types, as well as numerous predefined subtypes. You can, of course, define your own exceptions. However, Dart programs can throw any non-null object—not just Exception and Error objects - as an exception.

Production-quality code usually throws types that implement [Error](https://api.dartlang.org/stable/dart-core/Error-class.html) or [Exception](https://api.dartlang.org/stable/dart-core/Exception-class.html).

To handle code that can throw more than one type of exception, you can specify multiple catch clauses. The first catch clause that matches the thrown object’s type handles the exception. If the catch clause does not specify a type, that clause can handle any type of thrown object:

```dart
try {
  breedMoreLlamas();
} on OutOfLlamasException {
  // A specific exception
  buyMoreLlamas();
} on Exception catch (e) {
  // Anything else that is an exception
  print('Unknown exception: $e');
} catch (e) {
  // No specified type, handles all
  print('Something really unknown: $e');
}
```

You can specify one or two parameters to `catch()`. The first is the exception that was thrown, and the second is the stack trace (a [StackTrace](https://api.dartlang.org/stable/dart-core/StackTrace-class.html) object).

```dart
try {
  // ···
} on Exception catch (e) {
  print('Exception details:\n $e');
} catch (e, s) {
  print('Exception details:\n $e');
  print('Stack trace:\n $s');
}
```

To ensure that some code runs whether or not an exception is thrown, use a `finally` clause. If no `catch`clause matches the exception, the exception is propagated after the `finally` clause runs:

```dart
try {
  breedMoreLlamas();
} finally {
  // Always clean up, even if an exception is thrown.
  cleanLlamaStalls();
}
```

Dart is an object-oriented language with classes and mixin-based inheritance. Every object is an instance of a class, and all classes descend from Object.**Mixin-based inheritance** means that although every class (except for Object) has exactly one superclass, a class body can be reused in multiple class hierarchies.

Use `?.` instead of `.` to avoid an exception when the leftmost operand is null.

You can create an object using a *constructor*. Constructor names can be either `*ClassName*` or`*ClassName*.*identifier*`. For example, the following code creates `Point` objects using the `Point()` and `Point.fromJson()` constructors:

```dart
var p1 = Point(2, 2);
var p2 = Point.fromJson({'x': 1, 'y': 2});
```

Some classes provide [constant constructors](https://dart.dev/guides/language/language-tour#constant-constructors). To create a compile-time constant using a constant constructor, put the `const` keyword before the constructor name.

Constructing two identical compile-time constants results in a single, canonical instance:

```dart
var a = const ImmutablePoint(1, 1);
var b = const ImmutablePoint(1, 1);

assert(identical(a, b)); // They are the same instance!
```

The `const` keyword became optional within a constant context in Dart 2.

All instance variables generate an implicit *getter* method. Non-final instance variables also generate an implicit *setter* method. 

If you don’t declare a constructor, a default constructor is provided for you. The default constructor has no arguments and invokes the no-argument constructor in the superclass.

Subclasses don’t inherit constructors from their superclass. A subclass that declares no constructors has only the default (no argument, no name) constructor.

Use a named constructor to implement multiple constructors for a class or to provide extra clarity.

```dart
class Point {
  num x, y;

  Point(this.x, this.y);

  // Named constructor
  Point.origin() {
    x = 0;
    y = 0;
  }
}
```

Remember that constructors are not inherited, which means that a superclass’s named constructor is not inherited by a subclass. If you want a subclass to be created with a named constructor defined in the superclass, you must implement that constructor in the subclass.

By default, a constructor in a subclass calls the superclass’s unnamed, no-argument constructor. The superclass’s constructor is called at the beginning of the constructor body. If an [initializer list](https://dart.dev/guides/language/language-tour#initializer-list) is also being used, it executes before the superclass is called. In summary, the order of execution is as follows:

1. initializer list
2. superclass’s no-arg constructor
3. main class’s no-arg constructor