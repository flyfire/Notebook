# 2.里氏替换原则

所有引用基类的地方必须能透明地使用其子类的对象。Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.

只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常。

子类必须完全实现父类的方法。

如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。

子类中方法的前置条件必须与超类中被override的方法的前置条件相同或者更宽松。（子类override的方法的参数的参数类型必须是父类方法中参数的参数类型的父类型）

override或实现父类的方法时输出结果可以被缩小（返回类型可以是子类型，毕竟父类型reference可以指向子类型）。父类的，一个方法的返回值是一个类型T，子类的相同方法（override或overload）的返回值是S，那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一个类型，要么S是T的子类，为什么呢？分两种情况，如果是override，父类和子类的同名方法的输入参数是相同的，两个方法的返回值S小于等于T，这是override的要求。如果是overload，则要求方法的输入参数类型或数量不相同，在里氏替换原则要求下，就是子类的输入参数宽于或等于父类的输入参数，也就是说子类你写的这个方法是不会被调用的。